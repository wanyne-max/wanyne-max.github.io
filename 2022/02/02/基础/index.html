<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>基础 - Wanyne&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Wanyne&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Wanyne&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="增强 for 循环12345678for(声明语句 : 表达式)&amp;amp;#123;   &amp;#x2F;&amp;#x2F;代码句子&amp;amp;#125;声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法"><meta property="og:type" content="blog"><meta property="og:title" content="基础"><meta property="og:url" content="https://wanyne-max.github.io/2022/02/02/%E5%9F%BA%E7%A1%80/"><meta property="og:site_name" content="Wanyne&#039;s Blog"><meta property="og:description" content="增强 for 循环12345678for(声明语句 : 表达式)&amp;amp;#123;   &amp;#x2F;&amp;#x2F;代码句子&amp;amp;#125;声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/%E8%AE%BF%E9%97%AE.66iumh2sk6k0.webp"><meta property="og:image" content="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/%E6%93%8D%E4%BD%9C%E7%AC%A6.49e2ok2ykow0.webp"><meta property="og:image" content="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/object%E7%B1%BB.1cvymj8gmpb4.webp"><meta property="og:image" content="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.24zkwzp29nsw.webp"><meta property="article:published_time" content="2022-02-01T18:22:22.000Z"><meta property="article:modified_time" content="2022-04-06T01:22:15.839Z"><meta property="article:author" content="Wanyne W"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/%E8%AE%BF%E9%97%AE.66iumh2sk6k0.webp"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wanyne-max.github.io/2022/02/02/%E5%9F%BA%E7%A1%80/"},"headline":"基础","image":["https://raw.githubusercontent.com/wanyne-max/image-host/master/java/%E8%AE%BF%E9%97%AE.66iumh2sk6k0.webp","https://raw.githubusercontent.com/wanyne-max/image-host/master/java/%E6%93%8D%E4%BD%9C%E7%AC%A6.49e2ok2ykow0.webp","https://raw.githubusercontent.com/wanyne-max/image-host/master/java/object%E7%B1%BB.1cvymj8gmpb4.webp","https://raw.githubusercontent.com/wanyne-max/image-host/master/java/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.24zkwzp29nsw.webp"],"datePublished":"2022-02-01T18:22:22.000Z","dateModified":"2022-04-06T01:22:15.839Z","author":{"@type":"Person","name":"Wanyne W"},"publisher":{"@type":"Organization","name":"Wanyne's Blog","logo":{"@type":"ImageObject","url":"https://wanyne-max.github.io/img/logo.svg"}},"description":"增强 for 循环12345678for(声明语句 : 表达式)&amp;#123;   &#x2F;&#x2F;代码句子&amp;#125;声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。表达式：表达式是要访问的数组名，或者是返回值为数组的方法"}</script><link rel="canonical" href="https://wanyne-max.github.io/2022/02/02/%E5%9F%BA%E7%A1%80/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Wanyne&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2022-02-01T18:22:22.000Z" title="2022/2/2 上午2:22:22">2022-02-02</time>发表</span><span class="level-item"><time dateTime="2022-04-06T01:22:15.839Z" title="2022/4/6 上午9:22:15">2022-04-06</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E7%9F%A5%E8%AF%86%E5%8C%BA/">知识区</a></span><span class="level-item">28 分钟读完 (大约4126个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">基础</h1><div class="content"><h2 id="增强-for-循环"><a href="#增强-for-循环" class="headerlink" title="增强 for 循环"></a>增强 for 循环</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(声明语句 : 表达式)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="comment">//代码句子</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。</span><br><span class="line"></span><br><span class="line">表达式：表达式是要访问的数组名，或者是返回值为数组的方法</span><br></pre></td></tr></table></figure>

<p><escape><span id="more"></span></escape> </p>
<br>

<h2 id="修饰符访问控制优先级"><a href="#修饰符访问控制优先级" class="headerlink" title="修饰符访问控制优先级"></a>修饰符访问控制优先级</h2><p><img src="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/%E8%AE%BF%E9%97%AE.66iumh2sk6k0.webp" alt="访问"></p>
<br>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h2><p><img src="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/%E6%93%8D%E4%BD%9C%E7%AC%A6.49e2ok2ykow0.webp" alt="操作符"></p>
<br>

<h2 id="Number-amp-Math-类方法"><a href="#Number-amp-Math-类方法" class="headerlink" title="Number &amp; Math 类方法"></a>Number &amp; Math 类方法</h2><p><code>xxxValue()</code> 方法用于将 Number 对象转换为 xxx 数据类型的值并返回。  （xxx处可为byte、double、float、int、long、short）</p>
<p><code>compareTo()</code> 方法用于将 Number 对象与方法的参数进行比较。可用于比较 Byte, Long, Integer等。该方法用于两个相同数据类型的比较，两个不同类型的数据不能用此方法来比较。</p>
<p><code>valueOf()</code> 方法用于返回给定参数的原生 Number 对象值，参数可以是原生数据类型, String等。该方法是静态方法。该方法可以接收两个参数一个是字符串，一个是基数(进制)。</p>
<br>

<h2 id="object-类"><a href="#object-类" class="headerlink" title="object 类"></a>object 类</h2><p><img src="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/object%E7%B1%BB.1cvymj8gmpb4.webp" alt="object类"></p>
<br>

<h2 id="continue、break-和-return-的区别是什么？"><a href="#continue、break-和-return-的区别是什么？" class="headerlink" title="continue、break 和 return 的区别是什么？"></a>continue、break 和 return 的区别是什么？</h2><p><code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</p>
<p><code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</p>
<p><code>return</code> 用于跳出所在方法，结束该方法的运行。</p>
<br>

<h2 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员?"></a>静态方法为什么不能调用非静态成员?</h2><p>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</p>
<p>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</p>
<br>

<h2 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h2><p>对于基本数据类型来说，== 比较的是值。<br>对于引用数据类型来说，== 比较的是对象的内存地址。</p>
<p>因为 Java 只有值传递，所以，对于 <code>==</code> 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
<p><code>equals()</code> 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。equals()方法存在于Object类中，而Object类是所有类的直接或间接父类，因此所有的类都有equals()方法。</p>
<br>

<h2 id="String-equals-和-Object-equals-有何区别？"><a href="#String-equals-和-Object-equals-有何区别？" class="headerlink" title="String equals() 和 Object equals() 有何区别？"></a>String equals() 和 Object equals() 有何区别？</h2><p>String 中的 equals 方法是被重写过的，比较的是<code> String 字符串的值是否相等</code>。 Object 的 equals 方法是比较的<code>对象的内存地址</code>。</p>
<br>

<h2 id="hashcode的用处"><a href="#hashcode的用处" class="headerlink" title="hashcode的用处"></a>hashcode的用处</h2><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p>
<br>

<h2 id="那为什么不只提供-hashCode-方法呢？"><a href="#那为什么不只提供-hashCode-方法呢？" class="headerlink" title="那为什么不只提供 hashCode() 方法呢？"></a>那为什么不只提供 hashCode() 方法呢？</h2><p>这是因为两个对象的<code> hashCode值</code>相等并不代表<code> 两个对象</code>就相等。</p>
<br>

<h2 id="那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？"><a href="#那为什么两个对象有相同的-hashCode-值，它们也不一定是相等的？" class="headerlink" title="那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？"></a>那为什么两个对象有相同的 hashCode 值，它们也不一定是相等的？</h2><p>因为 hashCode() 所使用的哈希算法也许刚好会让多个对象传回相同的哈希值。越糟糕的哈希算法越容易碰撞，但这也与数据值域分布的特性有关（所谓哈希碰撞也就是指的是不同的对象得到相同的 hashCode )。</p>
<h2 id="总结-："><a href="#总结-：" class="headerlink" title="总结 ："></a>总结 ：</h2><p>如果两个对象的<code>hashCode值相等</code>，那这<code>两个对象不一定相等</code>（哈希碰撞）。</p>
<p>如果两个对象的<code>hashCode值相等</code>并且<code>equals()方法也返回 true</code>，我们才认为这<code>两个对象相等</code>。</p>
<p>如果两个对象的<code>hashCode 值不相等</code>，我们就可以直接认为这<code>两个对象不相等</code>。</p>
<br>

<h2 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h2><p>因为两个相等的对象的 hashCode 值必须是相等。也就是说如果 equals 方法判断两个对象是相等的，那这两个对象的 hashCode 值也要相等。如果重写 equals() 时没有重写 hashCode() 方法的话就可能<code>会导致</code> equals 方法判断是<code>相等的两个对象</code>，<code>hashCode值却不相等</code>。</p>
<br>

<h2 id="对象的相等与指向他们的引用相等-两者有什么不同"><a href="#对象的相等与指向他们的引用相等-两者有什么不同" class="headerlink" title="对象的相等与指向他们的引用相等,两者有什么不同?"></a>对象的相等与指向他们的引用相等,两者有什么不同?</h2><p><code>对象</code>的相等一般比较的是<code>内存中存放的内容</code>是否相等。</p>
<p><code>引用</code>相等一般比较的是他们指向的<code>内存地址</code>是否相等。</p>
<br>

<h2 id="对象实体与对象引用有何不同"><a href="#对象实体与对象引用有何不同" class="headerlink" title="对象实体与对象引用有何不同?"></a>对象实体与对象引用有何不同?</h2><p>new创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<br>

<h2 id="面向对象三大特征"><a href="#面向对象三大特征" class="headerlink" title="面向对象三大特征"></a>面向对象三大特征</h2><p>1、封装</p>
<p>2、继承</p>
<p>3、多态</p>
<br>

<h2 id="接口和抽象类有什么共同点和区别？"><a href="#接口和抽象类有什么共同点和区别？" class="headerlink" title="接口和抽象类有什么共同点和区别？"></a>接口和抽象类有什么共同点和区别？</h2><p><code>共同点：</code></p>
<p>都不能被实例化。</p>
<p>都可以包含抽象方法。</p>
<p>都可以有默认实现的方法（Java 8 可以用 default 关键在接口中定义默认方法）。</p>
<p><code>区别 ：</code></p>
<p>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系（比如说我们抽象了一个发送短信的抽象类，）。</p>
<p>一个类只能继承一个类，但是可以实现多个接口。</p>
<p>接口中的成员变量<code>只能是 public static final </code>类型的，不能被修改且必须有初始值，而抽象类的成员变量<code>默认 default</code>，可在子类中被重新定义，也可被重新赋值。</p>
<br>

<h2 id="深拷贝和浅拷贝区别？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别？什么是引用拷贝？"></a>深拷贝和浅拷贝区别？什么是引用拷贝？</h2><p><code>浅拷贝：</code>浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><code>深拷贝 ：</code>深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
<p><code>引用拷贝: </code>两个不同的引用指向同一个对象。</p>
<br>

<h2 id="String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的"><a href="#String、StringBuffer、StringBuilder-的区别？String-为什么是不可变的" class="headerlink" title="String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?"></a>String、StringBuffer、StringBuilder 的区别？String 为什么是不可变的?</h2><p><code>可变性</code></p>
<p>String 类中使用 final 关键字修饰字符数组来保存字符串，所以String 对象是不可变的。被 final 关键字修饰的类不能被继承，修饰的方法不能被重写，修饰的变量是基本数据类型则值不能改变，修饰的变量是引用类型则不能再指向其他对象。因此，final 关键字修饰的数组保存字符串并不是 String 不可变的根本原因，因为这个数组保存的字符串是可变的（final 修饰引用类型变量的情况）。</p>
<p>String 真正不可变有下面几点原因：</p>
<p>保存字符串的数组被 final 修饰且为私有的，并且String 类没有提供/暴露修改这个字符串的方法。</p>
<p>String 类被 final 修饰导致其不能被继承，进而避免了子类破坏 String 不可变。</p>
<p><code>线程安全性</code></p>
<p>String中的对象是不可变的，也就可以理解为常量，线程安全。</p>
<p>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</p>
<p>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</p>
<p><code>性能</code></p>
<p>每次对 String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象。</p>
<p>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 StringBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<p><code>总结：</code></p>
<p>操作少量的数据: 适用 String</p>
<p>单线程操作字符串缓冲区下操作大量数据: 适用 StringBuilder</p>
<p>多线程操作字符串缓冲区下操作大量数据: 适用 StringBuffer</p>
<br>

<h2 id="字符串拼接用“-”-还是-StringBuilder"><a href="#字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="字符串拼接用“+” 还是 StringBuilder?"></a>字符串拼接用“+” 还是 StringBuilder?</h2><p>对象引用和“+”的字符串拼接方式，实际上是通过 StringBuilder 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 String 对象 。</p>
<p>编译器不会创建单个 StringBuilder 以复用，会导致创建过多的 StringBuilder 对象。</p>
<p>若StringBuilder 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 StringBuilder 对象。</p>
<br>

<h2 id="泛型一般有三种使用方式-泛型类、泛型接口、泛型方法。"><a href="#泛型一般有三种使用方式-泛型类、泛型接口、泛型方法。" class="headerlink" title="泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。"></a>泛型一般有三种使用方式: 泛型类、泛型接口、泛型方法。</h2><p>1.<code>泛型类</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实例化泛型类：</span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br></pre></td></tr></table></figure>

<p>2.<code>泛型接口</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">实现泛型接口，不指定类型：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">实现泛型接口，指定类型：</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GeneratorImpl</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3.<code>泛型方法</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(E[] inputArray)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (E element : inputArray) &#123;</span><br><span class="line">        System.out.printf(<span class="string">&quot;%s &quot;</span>, element);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用：</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建不同类型数组： Integer, Double 和 Character</span></span><br><span class="line">Integer[] intArray = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">String[] stringArray = &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;World&quot;</span> &#125;;</span><br><span class="line">printArray(intArray);</span><br><span class="line">printArray(stringArray);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>常用的通配符:</p>
<p><code>？</code> 表示<code>不确定</code>的 Java 类型</p>
<p><code>T </code>(type) 表示<code>具体</code>的一个 Java 类型</p>
<p><code>K V </code>(key value) 分别代表 Java 键值中的 <code>Key Value</code></p>
<p><code>E </code>(element) 代表 <code>Element</code></p>
<br>

<h2 id="注解只有被解析之后才会生效，常见的解析方法有两种："><a href="#注解只有被解析之后才会生效，常见的解析方法有两种：" class="headerlink" title="注解只有被解析之后才会生效，常见的解析方法有两种："></a>注解只有被解析之后才会生效，常见的解析方法有两种：</h2><p>通过反射可以获取任意一个类的所有属性和方法，还可以调用这些方法和属性。基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解,就可以做进一步的处理。</p>
<p><code>编译期直接扫描</code> ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用@Override 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</p>
<p><code>运行期通过反射处理</code> ：像框架中自带的注解(比如 Spring 框架的 @Value 、@Component)都是通过反射来进行处理的。</p>
<br>

<h2 id="Exception-和-Error-有什么区别？"><a href="#Exception-和-Error-有什么区别？" class="headerlink" title="Exception 和 Error 有什么区别？"></a>Exception 和 Error 有什么区别？</h2><p>在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类:</p>
<ul>
<li><p>Exception :程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 <code>Checked Exception</code> (受检查异常，必须处理) 和 <code>Unchecked Exception</code> (不受检查异常，可以不处理)。</p>
</li>
<li><p>Error ：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
</li>
</ul>
<br>

<h2 id="Throwable-类常用方法？"><a href="#Throwable-类常用方法？" class="headerlink" title="Throwable 类常用方法？"></a>Throwable 类常用方法？</h2><p><code>String getMessage()</code>: 返回异常发生时的简要描述</p>
<p><code>String toString()</code>: 返回异常发生时的详细信息</p>
<p><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 Throwable 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 getMessage()返回的结果相同</p>
<p><code>void printStackTrace()</code>: 在控制台上打印 Throwable 对象封装的异常信息</p>
<p><img src="https://raw.githubusercontent.com/wanyne-max/image-host/master/java/Java%E5%BC%82%E5%B8%B8%E7%B1%BB%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84%E5%9B%BE2.24zkwzp29nsw.webp" alt="Java异常类层次结构图2"></p>
<br>

<h2 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h2><p><code>try块</code>： 用于捕获异常。其后可接零个或多个 catch 块，如果没有 catch 块，则必须跟一个 finally 块。</p>
<p><code>catch块</code>： 用于处理 try 捕获到的异常。</p>
<p><code>finally 块</code>： 无论是否捕获或处理异常，finally 块里的语句都会被执行。当在 try 块或 catch 块中遇到 return 语句时，finally 语句块将在方法返回之前被执行。</p>
<p>在某些情况下，finally 中的代码<code>不会被执行</code>。</p>
<p>1、finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。</p>
<p>2、程序所在的线程死亡。</p>
<p>3、关闭 CPU。</p>
<p><code>不要</code>在 finally 语句块中使用 <code>return</code>！当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。</p>
<br>

<h2 id="获取用键盘输入常用的两种方法"><a href="#获取用键盘输入常用的两种方法" class="headerlink" title="获取用键盘输入常用的两种方法"></a>获取用键盘输入常用的两种方法</h2><p><code>方法 1：通过 Scanner</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Scanner input = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">String s  = input.nextLine();</span><br><span class="line">input.close();</span><br><span class="line">Copy to clipboardErrorCopied</span><br></pre></td></tr></table></figure>

<p><code>方法 2：通过 BufferedReader</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader input = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(System.in));</span><br><span class="line">String s = input.readLine();</span><br></pre></td></tr></table></figure>


<br>

<h2 id="Java-IO-流的-40-多个类都是从如下-4-个抽象类基类中派生出来的"><a href="#Java-IO-流的-40-多个类都是从如下-4-个抽象类基类中派生出来的" class="headerlink" title="Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的"></a>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的</h2><p><code>InputStream</code> / <code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</p>
<p><code>OutputStream</code> / <code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</p>
<pre><code>  io流分类：
  按照流的流向分，可以分为输入流和输出流；
  按照操作单元划分，可以划分为字节流和字符流；
  按照流的角色划分为节点流和处理流。
</code></pre>
<br>

<h2 id="既然有了字节流-为什么还要有字符流"><a href="#既然有了字节流-为什么还要有字符流" class="headerlink" title="既然有了字节流,为什么还要有字符流?"></a>既然有了字节流,为什么还要有字符流?</h2><p><code>问题本质</code>：不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</p>
<p><code>回答</code>：字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是<code>非常耗时</code>，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个<code>直接操作字符的接口</code>，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>基础</p><p><a href="https://wanyne-max.github.io/2022/02/02/基础/">https://wanyne-max.github.io/2022/02/02/基础/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Wanyne W</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2022-02-02</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2022-04-06</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/02/02/mybatis/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">mybatis</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/02/02/%E5%B9%B6%E5%8F%91-%E5%9F%BA%E7%A1%80/"><span class="level-item">并发-基础</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Wanyne W"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Wanyne W</p><p class="is-size-6 is-block">所有命运的馈赠 早已暗中标注了价格</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">33</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">7</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">9</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/SQL/"><span class="level-start"><span class="level-item">SQL</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">学习笔记</span></span><span class="level-end"><span class="level-item tag">6</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%9F%A5%E8%AF%86%E5%8C%BA/"><span class="level-start"><span class="level-item">知识区</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2022/02/"><span class="level-start"><span class="level-item">二月 2022</span></span><span class="level-end"><span class="level-item tag">14</span></span></a></li><li><a class="level is-mobile" href="/archives/2022/01/"><span class="level-start"><span class="level-item">一月 2022</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/10/"><span class="level-start"><span class="level-item">十月 2021</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">13</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-01T18:22:22.000Z">2022-02-02</time></p><p class="title"><a href="/2022/02/02/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/">JVM-垃圾回收</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E5%8C%BA/">知识区</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-01T18:22:22.000Z">2022-02-02</time></p><p class="title"><a href="/2022/02/02/JVM-%E5%86%85%E5%AD%98/">JVM-内存</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E5%8C%BA/">知识区</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-01T18:22:22.000Z">2022-02-02</time></p><p class="title"><a href="/2022/02/02/Spring/">Spring</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E5%8C%BA/">知识区</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-01T18:22:22.000Z">2022-02-02</time></p><p class="title"><a href="/2022/02/02/Redis/">Redis</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E5%8C%BA/">知识区</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2022-02-01T18:22:22.000Z">2022-02-02</time></p><p class="title"><a href="/2022/02/02/SpringBoot/">SpringBoot</a></p><p class="categories"><a href="/categories/%E7%9F%A5%E8%AF%86%E5%8C%BA/">知识区</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Wanyne&#039;s Blog" height="28"></a><p class="is-size-7">   <span>&copy; 2022 Wanyne W</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">Made by Wanyne W</p><p class="is-size-7">Hope you have a good day！ ♥</p><p class="is-size-7">Creation date : 2021 08 05</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>