{"pages":[{"title":"关于我","text":"被酒莫惊春睡重 赌书消得泼茶香 当时只道是寻常","link":"/about/index.html"}],"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/05/hello-world/"},{"title":"blog搭建（记录踩过的坑）","text":"前两天整理资料的时候看到以前准备搭建的博客，想着趁空闲时间试着搞一个。每次搞个什么东西都磨磨蹭蹭的，这次索性直接莽 先是查找了市面上的常见架构，本来贼心动wordpress，但是看着太麻烦，其实是要用服务器太贵，直接放弃 最后选择的是hexo+lcarus搭建静态博客的方法，然后将博客push到github上存储。 （一）搭建环境 1、安装node.js首先要先安装node.js：https://github.com/hexojs/hexo/issues （注意要选择长期支持版 较稳定） 安装较简单，安装目标目录可以自定义，如果C盘较小就换到其他盘 2、安装gitgit 官方网站：https://git-scm.com/ 你如果不会用的话,可以去这个廖雪峰老师的网站: https://www.liaoxuefeng.com/wiki/896043488029600 输入 node -v npm -v git –version看一下版本号，若正常输出则说明成功了 3、创建GitHub Pages (仓库)在你的github主页, ​ 点击右上角 + 号 &gt; New repository ​ Repository name 中输入 你的用户名.github.io(若不这样，则会404) ​ 勾选 “Initialize this repository with a README” ​ Description 选填 点Create repository后你的博客地址就生成了 地址为: https://用户名.github.io （二）安装Hexo 1、安装打开终端 执行 npm install hexo-cli -g 全局安装Hexo. 2、创建博客创建blog文件夹用于存放博客md cd blog 进入博客目录 npm install 安装依赖 执行 npm install hexo-cli -g 全局安装Hexo. hexo s 启动服务 （三）选择主题在blog初始化的时候hexo就默认下载了landscape主题，对比了很多款，我现在正在用的这款是icarus，也可以到hexo的主题列表里面自己选择 https://hexo.io/themes/ 下载 进入博客根目录,打开git bash git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 下载完成之后需要修改配置在blog文件夹下 _config.yml文件 所有配置基本都在这里 找到theme: landscape 修改为theme: icarus 重启服务即可(hexo clean \\ hexo g \\ hexo s). （四）开始记录hexo默认是使用的markdown，执行hexo new 文章名 默认会在./source/_posts/ 文件夹下创建.md文件 同理 也可以把自己已经写好的.md文件放到这个目录下，然后执行 hexo g &amp;&amp; hexo s 打开浏览器就能看到编译好的html了 最后使用hexo d将修改后的内容push到GitHub上 常见问题修改了主题之后执行 hexo server可能会有如下报错 这是因为icarus主题所需的依赖没有安装. 按照提示安装依赖(类似如下) npm install –save bulma-stylus@0.8.0 hexo-component-inferno@^0.4.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 （五）hexo常用命令 clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information. （六）参考资料https://blog.csdn.net/marvine/article/details/89816846 https://blog.csdn.net/zemprogram/article/details/104288872 https://blog.csdn.net/ye17186/article/details/111564883 https://gitee.com/W4j1e/hexo-douban-list2","link":"/2021/08/05/blog%E6%90%AD%E5%BB%BA%EF%BC%88%E8%AE%B0%E5%BD%95%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%89/"},{"title":"UTC-UT-GMT  时区和时间戳","text":"格林尼治平时（Greenwich Mean Time），简称 GMT 世界时（Universal Time），简称 UT 协调世界时（Coordinated Universal Time），简称 UTC UTC, UT, GMT 三者出现的先后顺序： GMT -&gt; UT -&gt; UTC，我们可以把 GMT 和 UTC 看作一样的。 GMT 和 UTC 都是用 秒 数来计算的。 时区 全球划分为 24 个时区 时区可以用 UTC 表示，范围为 UTC-12 — UTC-11 — UTC-1 — UTC — UTC-1 — UTC+11 — UTC+12，依次增加 相差多少个时区，就是相差多少个小时 时区可以按 区域/位置 的格式表示，就可以得到一个独有的名称（时区有很多种表示方式） 以 中国时区 为例。 China Standard Time (CST), UTC +8、 无夏令时，全年 UTC 偏移量不变 中国的 IANA 时区标识符为 Asia/Shanghai。 时间戳 时间戳（Timestamp）是指字符串或编码信息用于辨识记录下来的时间日期。国际标准为 ISO 8601 时间戳是从 协调世界时（UTC） 1970 年 1 月 1 日 0 时 0 分 0 秒 起至现在的总秒数，不考虑闰秒 时间戳是用无符号整数表示 时间戳 和 UTC 进行转换，UTC 和 时区 进行转换，因此 时间戳 也可以和 UTC 进行转换 有 秒级（10 位）， 毫秒级（13 位） 的时间戳，也有纳米级（19 位） 的时间戳，如 Java 就可以处理到纳米级 本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：2015-04-19 12:20:00 实际上就是UTC+8:00时区的时间：2015-04-19 12:20:00 UTC+8:00 而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：2015-04-19 04:20:00 UTC+0:00 原文链接：https://blog.csdn.net/zheng_lan_fang/article/details/79448965 因为时区的关系，由于没设置使用者的时区，所以就会看到在一些系统上会出现时间慢了 8 个小时的现象（以北京时区为例） 不同的编程语言可以通过设置的方式来调整时区 不同的编程语言 格式化 时间的方式也不同（如：yyyy-mm-dd hh:mm:ss），为确保统一，我们可以使用时间戳（mysql，Java，JavaScript 存放时间都用 时间戳，就不会产生写入和读出不一致了。","link":"/2021/08/08/UTC-UT-GMT%20%20%E6%97%B6%E5%8C%BA%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3/"},{"title":"如何修复失败的Git提交","text":"在使用 Git 的时候，大家都碰到过忘记添加文件或是忘记写注释等等糟心的情况。幸运的是，Git 中有一些命令可以帮助处理这些常见的情况，下面列出常见的解决方法。 1.修改提交信息在提交消息的时候你发现了提交内容错误。这个是可以修改的： git commit --amend -m &quot;new message&quot; 2.添加文件到最后一次提交更改已经提交，但又忘记添加文件了。没问题，我们仍然可以将文件添加到这次提交中： git add &lt;file_name&gt; git commit --amend HEAD~1 3.撤消提交如果要撤消最近一次提交但保留更改，可执行以下操作： git reset --soft HEAD~1 如果要撤消提交和更改，可执行以下操作：注意，确定是要丢弃更改。 git reset --hard HEAD~1 还有一种情况是，如果要撤消所有的本地更改，则可以重置为分支的原始版本： git reset --hard origin/&lt;branch_name&gt; 如果要撤消提交而不修改现有历史记录，则可以使用 git revert，此命令通过创建新的提交来撤消提交。 git revert HEAD 如果你刚解决了冲突，完成了合并，并且推送到了原始版本。撤消已经推送到远程分支的合并提交的安全方法是使用 git revert 命令：(其中commit_id 是要还原的合并提交 id。) git revert -m 1 &lt;commit_id&gt; 注意要点： 可以撤消任意数量的提交。例如：git reset HEAD~3（返回 HEAD 之前的 3 个提交)；git reset --hard &lt;commit_id&gt;（返回特定的提交）。 如果尚未推送提交，并且你不想引入糟糕的提交到远程分支，可以使用 git reset。 使用 git revert 还原已经推送到远程分支的合并提交。 使用 git log 查看提交历史。","link":"/2021/08/08/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%E5%A4%B1%E8%B4%A5%E7%9A%84Git%E6%8F%90%E4%BA%A4/"},{"title":"http和https的那些七七八八","text":"搭博客的这段时间，发现有些博客地址前面有个不安全的标志，而大佬们的博客前面都是一个锁。后来百度的才知道，原来二者所用的协议不一样： 不安全的标志是因为用的是Http协议，访问的是80端口，传输的数据如果不自己进行加密，传输的是明文 大佬们用的是Https协议，访问的是443端口，传输的数据进行了加密，安全性更好 Http协议与Https协议Http协议超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础，现在我们的网页浏览器，各种服务的接口，还有一些流应用都是基于Http协议的，在这里我就不赘述了，详情可以参考这篇博客，里面已经介绍的十分清楚了。 Https协议因为https协议涉及一些密码学的知识，先扫个盲 数据的加密与解密对称加密——服务器和客户端都有相同的密钥 对称加密：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，但是安全性低，一旦私钥泄露，数据就有被盗取的风险。 其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文解密过程如下： 密文 + 解密算法 + 私钥 =&gt; 明文 非对称加密——顾名思义服务器和客户端拥有的密钥不对等 非对称加密：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。 被公钥加密过的密文只能被私钥解密，过程如下： 明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文 被私钥加密过的密文只能被公钥解密，过程如下： 明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文 由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 Https协议传输原理HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输。https协议的基础是http协议，而且在一次https请求中，包含了两次http请求。 为了安全和灵活性，https同时使用了对称加密和非对称加密，用非对称加密传输密钥，用对称加密传输数据，这样一来，既可以防止他人拿到密钥，又减少了加密和解密花费的时间。下图展示了一次Https请求的流程： 一共分为8步，产生了两次http请求，期间有三个密钥客户端产生的随机密钥，服务器公钥，服务器私钥： client对server发起请求；第一次http请求 server端获取自己的公钥； server端将自己的公钥发给client端； client检验该公钥是否有效，无效则抛安全异常，有效则创建随机密钥，并用公钥加密随机密钥； client用随机密钥加密传输的请求，并将请求和用公钥加密后的随机密钥一起发给server；第二次http请求 server用自己的私钥解密随机密钥，得到随机密钥后，解密请求。 server对请求做出响应，将响应用随机密钥加密后，传给client端。 client端用随机密钥，解密出响应，并在浏览器上展示。 至此，一次https请求执行完毕。从中我们可以看到，私钥一直由服务器保存，我们传输的是公钥和客户端产生的随机密钥，所以只要私钥不被泄露，监听者是无法解密我们的请求与响应的。","link":"/2021/08/07/http%E5%92%8Chttps%E7%9A%84%E9%82%A3%E4%BA%9B%E4%B8%83%E4%B8%83%E5%85%AB%E5%85%AB/"},{"title":"域名为什么可以以 . 结尾","text":"奇怪的知识增加了。 . 是根域名。访问所有域名理论上都是由根域名开始解析的。 比如访问 http://www.cctv.com 这个网址，计算机先知道这个网址对应的ip才能访问。所以要做一次解析，也就是找到 http://www.cctv.com 对应的IP，这个过程叫“DNS解析”. 这个过程怎么进行呢?分 4 步, 计算机先询问 “.”根域名服务器, “管理com域名解析服务器在哪里?” 得到”com域名解析服务器”的地址，再去询问”管理cctv的域名解析服务器在哪里?” 得到”cctv域名解析服务器”的地址，再去询问”www对应的服务器在哪里?” http://www.cctv.com 的地址 GET! 于是我们发现，所有的网址的解析都需要先去访问这个根域名服务器，为了优化输入增加效率，许多浏览器就省略掉它了，但是在DNS协议里面，还是会默默地把这个“.”加上的。","link":"/2021/08/07/%E5%9F%9F%E5%90%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BB%A5%20.%20%E7%BB%93%E5%B0%BE/"},{"title":"如何嵌入B站视频","text":"B 站的网页版已经提供了内嵌的 iframe 代码，我们只需要一键复制后就可以直接使用。 原版链接&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=60731116&amp;bvid=BV1qt411j7fV&amp;cid=106015992&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 自适应版这样原版链接一般来说是够用了，但是它也有问题，我们能不能搞一种更通用的引用方式呢？ &lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//player.bilibili.com/player.html?aid=60731116&amp;bvid=BV1qt411j7fV&amp;cid=106015992&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 参数说明： key 说明 aid 之前 B 站使用的 AV 号 bvid 目前的 BV 号 page 第几个视频, 起始下标为 1 (默认值也是为 1)就是 B 站视频, 选集里的, 第几个视频 as_wide 是否宽屏 【1: 宽屏, 0: 小屏】 high_quality 是否高清 【1: 高清(最高1080p) / 0: 最低视频质量(默认)】 danmaku 是否开启弹幕 【1: 开启(默认), 0: 关闭】","link":"/2021/08/07/%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5B%E7%AB%99%E8%A7%86%E9%A2%91/"},{"title":"常用的一些git操作命令","text":"远程克隆git clone XXXX.git 克隆远程指定分支git clone -b 分支名 XXXX.git 创建本地分支git branch 分支名 删除本地分支git branch -d 分支名 查看远程分支git branch -a 删除远程分支git branch -r -d origin/jinsong git push origin --delete 分支名 切换到分支git checkout 分支名 查看所在分支git branch -a 查看所有修改了还没有add的文件git diff 查看单个修改了还没有add的文件git diff 文件名 add所有文件git add -A add某个文件git add 文件全名 commit操作修改了文件必须先add才能commit git commit -m \"提交的描述信息\" 拉取远程分支到本地push前最好先用pull更新本地代码 git pull origin 分支名：分支名 （前一个是远程分支名，后一个是本地分支名） git pull origin 分支名（远程和本地分支同名） 推送本地分支到远程必须本地已经切换到“分支名” git push origin 分支名：分支名 （前一个是本地分支名，后一个是会在远程生成的分支名，通常都用同一个名字） git push origin 分支名 （本地和远程分支同名） 远程已有“分支名”并且已经关联本地“分支名”且本地已经切换到“分支名”git push 远程已有“分支名”但未关联本地“分支名”且本地已经切换到“分支名”git push -u origin/分支名 查看远程仓库信息git remote -v/分支名 本地添加新的远程仓库，远程仓库是空的git remote add 给远程仓库在本地起个名字 XXXX.git 推送本地分支到对应的远程仓库git push 远程仓库名字 分支名 关联本地和远程分支git branch --set-upstream-to=origin/远程分支名 本地分支名 查看版本号，回滚到指定版本，推送到远程git log git reset --hard 版本号 git push -f origin 分支名","link":"/2021/08/06/%E5%B8%B8%E7%94%A8%E7%9A%84git%E6%93%8D%E4%BD%9C/"},{"title":"杂烩","text":"常见字符函数和字符串函数https://blog.csdn.net/tanrui519521/article/details/81162267 C语言中宏定义的使用https://blog.csdn.net/imgosty/article/details/81901183 文件操作(FILE)与常用文件操作函数——C语言https://www.cnblogs.com/lanhaicode/p/10320097.html C语言 枚举详解https://blog.csdn.net/qq_41673920/article/details/85261762","link":"/2021/08/10/%E6%9D%82%E7%83%A9/"},{"title":"正则表达式笔记","text":"正则过于重要（最近越来越多用到：Java的split函数、js、nginx的配置、Linux），但是我基本8会写，所以一边学一边记录下。 工具/网站安利 RegExp Tester：一个用于测试的chrome扩展，体积小且方便。 regexone：交互式学习和练习正则表达式的网站。 基础语法(PS:因为我就看会了这点，有不对的还请各位大佬指出，也可能手抖敲错了) 元字符 \\b：代表着单词的开头或结尾，也就是单词的分界处，它只匹配一个位置。 \\w：匹配字母或数字或下划线或汉字。 \\d：匹配数字，可以代替0到9之间的任何数字。 . ：匹配任何单个字符（字母，数字，空格，所有内容），实际上会覆盖句号字符的匹配，因此，为了专门匹配句号，使用斜杠\\来使句号转义。 \\s：匹配任意的空白符。 ^：匹配字符串的开始。 $：匹配字符串的结束。 ()：小括号来指定子表达式(也叫做分组)，然后可以对这个表达式指定各项操作。 转义查找元字符本身需要\\转义，例： regtest\\.py 匹配 regtest.py。 C:\\\\Windows 匹配 C:\\Windows。 反义 \\B：匹配不是单词开头或结束的位置。 \\W：匹配任意不是字母，数字，下划线，汉字的字符。 \\D：匹配任意非数字的字符。 \\S：匹配任意不是空白符的字符。 [\\^x]：匹配除了x以外的任意字符。 [\\^aeiou]：匹配除了aeiou这几个字母以外的任意字符。 例： \\S+ ：匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt; ：匹配用尖括号括起来的以a开头的字符串。 重复 * ：重复零次或更多次D + ：重复一次或更多次 ? ：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n到m次 例： Windows\\d+ ：匹配Windows后面跟1个或更多数字。 \\^\\w+ ：匹配 一行的第一个单词（或整个字符串的第一个单词）。 字符范围[]表示法中： -：表示字符范围。 ^ ：表示不要某几个字符。 例： [0-6] ：仅会匹配从零到六个的任何一位数字字符。 [^ np] ：将仅匹配任何单个字符，但字母n至p除外。 后向引用、分组、捕获默认情况下，每个分组会自动拥有一个组号，规则 是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 捕获 (exp) ：匹配exp,并捕获文本到自动命名的组里。 (?exp) ：匹配exp,并捕获文本到名称为name的组里，也可以写成 (?’name’exp)。 (?:exp) ：匹配exp,不捕获匹配的文本，也不给此分组分配组号。（PS：不会改变正则表达式的处理方式，只是这样的组匹配的内容 不会像前两种那样 被捕获到某个组里面，也不会拥有组号。 零宽断言 (?=exp) ：匹配exp前面的位置 (?&lt;=exp) ：匹配exp后面的位置 (?!exp) ：匹配后面跟的不是exp的位置 (?&lt;!exp) ：匹配前面不是exp的位置 注释 (? #comment) ：这种类型的分组不对正则表达式的处理产生任何影响，用于提 供注释让人阅读 懒惰匹配匹配尽可能少的字符 *? ：重复任意次，但尽可能少重复 +? ：重复1次或更多次，但尽可能少重复 ??：重复0次或1次，但尽可能少重复 {n,m}?：重复n到m次，但尽可能少重复 {n,}?：重复n次以上，但尽可能少重复 常用的部分正则表达式整数或者小数：^[0-9]+\\.{0,1}[0-9]{0,2}$。 只能输入数字：^[0-9]*$。 只能输入n位的数字：^\\d{n}$。 只能输入至少n位的数字：^\\d{n,}$。 只能输入m到n位的数字：^\\d{m,n}$。 只能输入零和非零开头的数字：^(0|[1-9][0-9]*)$。 只能输入有两位小数的正实数：^[0-9]+(.[0-9]{2})?$。 只能输入有1到3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$。 只能输入非零的正整数：^\\+?[1-9][0-9]*$。 只能输入非零的负整数：^\\-[1-9][]0-9″*$。 只能输入长度为3的字符：^.{3}$。 只能输入由26个英文字母组成的字符串：^[A-Za-z]+$。 只能输入由26个大写英文字母组成的字符串：^[A-Z]+$。 只能输入由26个小写英文字母组成的字符串：^[a-z]+$。 只能输入由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$。 只能输入由数字、26个英文字母或者下划线组成的字符串：^\\w+$。 验证用户密码：^[a-zA-Z]\\w{5,17}$。 正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。验证是否含有^%&amp;’,;=?$\\等字符：[^%&amp;',;=?$\\x22]+。 只能输入汉字：^[\\u4e00-\\u9fa5]{0,}$。 验证Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$。 验证InternetURL：^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$。 123验证电话号码：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$。正确格式为：XXX-XXXXXXX、XXXX-XXXXXXXX、XXX-XXXXXXX、XXX-XXXXXXXX、XXXXXXX和XXXXXXXX。 验证身份证号（15位或18位数字）：^\\d{15}|\\d{18}$。 12345验证一年的12个月：^(0?[1-9]|1[0-2])$。正确格式为：”01″～”09″和”1″～”12″。验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$正确格式为；”01″～”09″和”1″～”31″。 匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]。 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]。 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function(){return this.replace(/[^\\x00-\\xff]/g,”aa”).length;} 匹配空行的正则表达式：\\n[\\s| ]*\\r 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\\/(.*)&gt;|&lt;(.*)\\/&gt; 12345678910111213匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：String.prototype.trim = function(){return this.replace(/(^\\s*)|(\\s*$)/g, “”);}利用正则表达式分解和转换IP地址：下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：function IP2V(ip){re=/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g //匹配IP地址的正则表达式if(re.test(ip)){return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1}else{throw new Error(“Not a valid IP address!”)}}//上面的程序直接用split函数来分解var ip=”10.100.20.168″ip=ip.split(“.”)alert(“IP值是：”+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1)) 匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 匹配网址URL的正则表达式：http://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)? 利用正则表达式限制网页表单里的文本框输入内容：用正则表达式限制只能输入中文： onkeyup=”value=value.replace(/[^\\u4E00-\\u9FA5]/g,”)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\u4E00-\\u9FA5]/g,”))” 用正则表达式限制只能输入全角字符： onkeyup=”value=value.replace(/[^\\uFF00-\\uFFFF]/g,”)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\uFF00-\\uFFFF]/g,”))” 用正则表达式限制只能输入数字： onkeyup=”value=value.replace(/[^\\d]/g,”) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\d]/g,”))” 用正则表达式限制只能输入数字和英文： onkeyup=”value=value.replace(/[\\W]/g,”) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\d]/g,”))” 123匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]匹配双字节字符(包括汉字在内)： [^\\x00-\\xff]用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）匹配空白行的正则表达式：\\n\\s*\\r 可以用来删除空白行匹配HTML标记的正则表达式（仅对部分简单情况适用）：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; 匹配首尾空白字符的正则表达式：^\\s*|\\s*$ 可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 表单验证时很实用匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]* 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 表单验证时很实用匹配国内电话号码：\\d{3}-\\d{8}|\\d{4}-\\d{7} 匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]{4,} 从10000开始匹配中国邮政编码(中国邮政编码为6位数字)：[1-9]\\d{5}(?!\\d) 匹配ip地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?) 匹配正整数: ^-[1-9]\\d*$ 匹配负整数: ^-?[1-9]\\d*$ 匹配整数: ^[1-9]\\d*|0$ 匹配非负整数（正整数 + 0）: ^-[1-9]\\d*|0$ 匹配非正整数（负整数 + 0）: ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 匹配正浮点数: ^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 匹配负浮点数: ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 匹配浮点数: ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 匹配非负浮点数（正浮点数 + 0）: ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 匹配非正浮点数（负浮点数 + 0）: ^[A-Za-z]+$ (处理大量数据时有用，具体应用时注意修正匹配特定字符串) 匹配由26个英文字母组成的字符串: ^[A-Z]+$ 匹配由26个英文字母的大写组成的字符串: ^[a-z]+$ 匹配由26个英文字母的小写组成的字符串: ^[A-Za-z0-9]+$ Email : /^\\w+([-+.]\\w+)*@\\w+([-.]\\\\w+)*\\.\\w+([-.]\\w+)*$/ isEmail1 : /^\\w+([\\.\\-]\\w+)*\\@\\w+([\\.\\-]\\w+)*\\.\\w+$/; isEmail2 : /^.*@[^_]*$/; Phone : /^((\\(\\d{3}\\))|(\\d{3}\\-))?(\\(0\\d{2,3}\\)|0\\d{2,3}-)?[1-9]\\d{6,7}$/ Mobile : /^((\\(\\d{3}\\))|(\\d{3}\\-))?13\\d{9}$/","link":"/2021/08/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"},{"title":"设置[阅读全文]","text":"在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 1、在文章中使用&lt;!– more –&gt; 手动进行截断，Hexo 提供的方式 推荐(也可使用&lt;escape&gt;&lt;!– more –&gt;&lt;/escape&gt;) 2、在文章的 front-matter 中添加 description，并提供文章摘录 3、自动形成摘要，在主题配置文件中添加： auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定 建议使用&lt;!– more –&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。","link":"/2021/08/06/%E8%AE%BE%E7%BD%AE-%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87/"},{"title":"网站流量小知识","text":"名称 全称 作用 PV Page view 页面浏览量，用户每打开 1 个网站页面，记录 1 个 PV；用户多次打开同一页面，PV 值累计多次。 UV Unique visitor 网站独立访客；1 天内相同访客多次访问网站，只计算为 1 个独立访客 IP Internet Protocol 1 天之内（00:00 ~ 24:00），访问网站的不重复的 IP 数 VV Viedo view 一个统计周期内，视频被打开的次数","link":"/2021/08/06/%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"title":"指针","text":"1、指针与动态内存分配动态内存管理：在程序运行过程中向计算机申请分配一段存储单元或把早先申请的内存给计算机。 在编写程序时，通常不知道需要处理的数据量，或者难以估计所需处理数据量的变动程度。在这种情况下，要达到有效的资源利用，必须在运行时动态地分配所需内存，并在使用完毕后尽早释放不需要的内存，这就是动态内存分配的原理。 动态内存管理同时还具有一个优点：当程序在具有更多内存的系统上需要处理更多的数据时，不需要重写程序。 malloc函数和free函数1.malloc函数申请分配内存空间 定义：void *malloc(usigned size) 返回：NULL或一个指针 说明：申请成功则返回分配空间的起始地址，否则返回NULL。 2.free函数是malloc函数的逆过程 定义：void free(ptr) 返回：无 说明：把指针ptr所指向的一段内存单元释放两个函数都包含在头文件stdlib.h和malloc.h中。 动态内存分配的例子： 123456789101112131415161718192021222324#include&lt;stdio.h&gt;#include&lt;malloc.h&gt;#include&lt;stdlib.h&gt;int main(){ int* p; if ((p = (int*)malloc(sizeof(int))) == NULL) { printf(&quot;error on malloc!&quot;); exit(1); } *p = 580; printf(&quot;%5d,%ld\\n&quot;, *p, p); free(p); if ((p = (int*)malloc(sizeof(int))) == NULL) { printf(&quot;error on malloc!&quot;); exit(1); } *p = 1200; printf(&quot;%d,%ld\\n&quot;, *p, p); free(p); return 0;} 指针类型数据 定义 含义 int *p p为指向整型数据的指针变量 int *p[n] 定义指针数组p，由n个指向整型数据的指针元素组成 int (*p)[n] p为指向含n个整型元素的一维数组的指针变量 int *p(形参列表) p是返回指针的函数，该指针指向整型数据类型 int (*p)(形参表) p为指向函数的指针，该函数返回一个整型值 void *p p是可以指向任何类型数据的指针变量 int **p p是一个二级指针变量，它指向一个指向整形数据的指针变量 指针变量赋值的含义 赋值格式 含义 p=&amp;a 将变量a的地址赋值给指针变量p p=array；或p&amp;array[0] 将数组array的首地址赋给指针变量p p=&amp;array[i] 将数组元素array[i]的地址赋给指针变量p p=function 将函数function()的入口地址赋给指针变量p p1=p2 将指针变量p2的值赋给指针变量p1 p=p+i 将指针变量p往后挪动i个元素位置（仅限于数组情形） 2、指针与数组对指针数组和数组指针的概念，相信很多C程序员都会混淆。下面通过两个简单的语句来分析一下二者之间的区别，示例代码如下所示： 12int *p1[5]；int (*p2)[5]； 首先，对于语句“intp1[5]”，因为“[]”的优先级要比“”要高，所以 p1 先与“[]”结合，构成一个数组的定义，数组名为 p1，而“int*”修饰的是数组的内容，即数组的每个元素。也就是说，该数组包含 5 个指向 int 类型数据的指针，如图 1 所示，因此，它是一个指针数组。 其次，对于语句“int(p2)[5]”，“()”的优先级比“[]”高，“”号和 p2 构成一个指针的定义，指针变量名为 p2，而 int 修饰的是数组的内容，即数组的每个元素。也就是说，p2 是一个指针，它指向一个包含 5 个 int 类型数据的数组，如图 2 所示。很显然，它是一个数组指针，数组在这里并没有名字，是个匿名数组。 由此可见，对指针数组来说，首先它是一个数组，数组的元素都是指针，也就是说该数组存储的是指针，数组占多少个字节由数组本身决定；而对数组指针来说，首先它是一个指针，它指向一个数组，也就是说它是指向数组的指针，在 32 位系统下永远占 4 字节，至于它指向的数组占多少字节，这个不能够确定，要看具体情况。 了解指针数组和数组指针二者之间的区别之后，继续来看下面的示例代码： 1234int arr[5]={1，2，3，4，5};int (*p1)[5] = &amp;arr;/*下面是错误的*/int (*p2)[5] = arr; 不难看出，在上面的示例代码中，&amp;arr 是指整个数组的首地址，而 arr 是指数组首元素的首地址，虽然所表示的意义不同，但二者之间的值却是相同的。那么问题出来了，既然值是相同的，为什么语句“int(p1)[5]=&amp;arr”是正确的，而语句“int(p2)[5]=arr”却在有些编译器下运行时会提示错误信息呢（如在 Microsoft Visual Studio 2010 中提示的错误信息为“a value of type”int“cannot be used to initialize an entity of type”int()[5]””）？ 其实原因很简单，在 C 语言中，赋值符号“=”号两边的数据类型必须是相同的，如果不同，则需要显示或隐式类型转换。在这里，p1 和 p2 都是数组指针，指向的是整个数组。p1 这个定义的“=”号两边的数据类型完全一致，而 p2 这个定义的“=”号两边的数据类型就不一致了（左边的类型是指向整个数组的指针，而右边的数据类型是指向单个字符的指针），因此会提示错误信息。 3、指针与字符串一、char类型的长度为1，而字符串字面量的长度为412printf(&quot;%d\\n&quot;, sizeof(char));//1printf(&quot;%d\\n&quot;, sizeof('a'));//4 二、字符串字面量看作常量，无法修改字符串。12345678#include&lt;stdio.h&gt;int main(){ char *tabHeader = &quot;Sound&quot;; *tabHeader = 'L'; printf(&quot;%s\\n&quot;, tabHeader); return 0;} 上面程序运行报错。为了自己好，不要去修改字符串常量值，不然你是在给自己找麻烦。 三、字符串初始化1.初始化char数组char header[]=&quot;Media Player&quot;; 字面量“Media Player的长度为12个字符”，表示这个字面量需要13个字节，我们就为数组分配了13个字节。初始化操作会把这些字符复制到数组中，以NUL结尾。 12char header[] = &quot;Media Player&quot;;printf(&quot;%d\\n&quot;, sizeof(header));//输出13 也可以使用strcpy函数初始化数组 12char header[13];strcpy(header, &quot;Media Player&quot;); 下面的赋值是不合法的，我们不能把字符串字面量的地址赋给数组名字。 12char header[13];header = &quot;Media Player&quot;;//表达式必须是可修改的左值 2.初始化char指针最常用的方法是使用malloc和strcpy函数分配内存并将字面量复制到字符串中： 12char *header = (char *)malloc(strlen(&quot;Media Player&quot; + 1));strcpy(header, &quot;Media Player&quot;); 在决定malloc函数要用到的字符串长度时，要注意以下事项。 一定要记得算上终结符NUL； 不要用sizeof操作符，而是用strlen函数来确定已有字符串的长度，strlen不会算上‘\\0’； sizeof操作符会返回数组和指针的长度，而不是字符串的长度。 我们可以将字符串字面量的地址直接赋值给字符指针，不过这样就不会产生字符串的副本： char *header=&quot;Media Player”; 试图用字符字面量来初始化char指针不会起作用。因为字符字面量是int类型，这其实是尝试吧整数赋给字符指针。这样会造成应用程序在解引指针时终止： 12char *p = 'h';//char *与int的间接级别不同，虽然这一行不报错，但是解引时会出错。不合法。printf(&quot;%c\\n&quot;, *p);//报错 给char*指针赋值，这样都是可以的： char *s;s=”123”; char *s=”123”;s=”456”; 3.从标准输入初始化字符串1234567891011121314#include&lt;stdio.h&gt;int main(){ char a[10]; char *b = (char *)malloc(sizeof(char) * 10); printf(&quot;Enter a array:\\n&quot;); scanf(&quot;%s&quot;, a);//输入字符后，会自动加上\\0，所以只能输9个字符。 printf(&quot;%s&quot;, a); printf(&quot;Enter b array:\\n&quot;); scanf(&quot;%s&quot;, b); printf(&quot;%s\\n&quot;, b); return 0;} 从标准输入读入字符串时可能犯得错误： 123char *command;printf(&quot;Enter a Command:\\n&quot;);scanf(&quot;%s&quot;, command);//没有分配内存 4.字符串位置小结我们可能将字符串分配在几个地方，下面解释了几种可能的变化，下图说明了这些字符串在内存中的布局 1234567891011char *globalHeader = &quot;Chapter&quot;;char globalArrayHeader[] = &quot;Chapter&quot;;void displayHeader(){ static char * staticHeader = &quot;Chapter&quot;; char *localHeader = &quot;Chapter&quot;; static char staticArrayHeader[] = &quot;Chapter&quot;; char localArrayHeader[] = &quot;Chapter&quot;; char *heapHeader = (char *)malloc(strlen(&quot;Chapter&quot; + 1)); strcpy(heapHeader, &quot;Chapter&quot;);} 4、指针与函数1.指针可以调用函数函数名本身就是一个指针（地址），这个地址就是函数的入口地址 123456789101112int sum(int a, int b){ return a + b;} int main(){ printf(&quot;%p\\n&quot;, sum); system(&quot;pause&quot;); return 0;} 可以发现，函数名就是一个地址 2.函数指针变量定义格式：返回值 （*变量名）（参数1，参数2，，，参数n） 1234567891011int sum(int a, int b) {} int (*pSum)(int a, int b); //函数指针变量，参数名可以省略 pSum = sum; //给指针赋地址值printf(&quot;%p\\n&quot;, sum); int(*pSum)(int, int);pSum = sum; printf(&quot;%p\\n&quot;, pSum); 可以发现，两者地址相同 3.函数指针类型定义格式：typedef 返回值 （* 类型名）（参数1，参数2，，，参数n）； 123typedef int(*PSUM)(int, int);PSUM pSum2 = sum;PSUM pSum3 = sum; 这样的好处就是，首先通过typedef定义一个函数指针类型PSUM，定义完后，PSUM就相当于一种新的类型，可以用此类型去定义其他函数指针变量，就不用每次都使用int(*pSum)(int, int);来定义一个函数指针变量 4.函数指针的使用当成函数名一样来使用！ 1234567int(*pSum)(int, int);pSum = sum; typedef int(*PSUM)(int, int);PSUM pSum2 = sum; cout &lt;&lt; sum(111, 222) &lt;&lt; &quot; &quot; &lt;&lt; pSum(111, 222) &lt;&lt; &quot; &quot; &lt;&lt; pSum2(111, 222) &lt;&lt; endl; 得到的结果一致，使用的方式也和一般的函数调用一致 5.多级复杂函数指针例如：int (* (* p)(int) )(int); 先看红色字体，p是一个函数指针，指向的函数A参数为一个int型，返回的值又是一个指针；然后返回的指针又是一个函数指针，指向的函数B参数为一个int型，返回的值是一个int型 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std; //定义一个函数，参数为int型，返回输入的倍数，也是一个int型int fun0(int a){ return a + a;} //定义一个函数指针类型，参数为一个int型，返回为inttypedef int(*PFUN)(int); //该函数返回一个函数指针，参数为int型PFUN fun(int a){ return fun0;} int main(){ int(*(*p)(int))(int); p = fun; cout &lt;&lt; p(111)(10) &lt;&lt; endl; system(&quot;pause&quot;); return 0;} 1）解释一下p(111)(10)的含义，首先p(111)调用函数fun，该函数返回函数fun0的地址，在函数的地址后面加上(10)，表示输入参数10，最后返回20 2）解释一下为什么在定义函数指针类型的时候要返回值int，即typedef int (PFUN)(int);里面的第一个int，如果使用float行不呢，答案肯定是不行的，这里的int依据的是定义函数指针p那里最左边的int，即int ( (* p)(int) )(int);里面的第一个int，要求返回int。如果我们改成float (* (* p)(int) )(int);那么相应的函数指针类型那里也要改成float，即typedef float (*PFUN)(int);最后在定义函数fun0那里，也要改成返回float型 5、指针与结构体结构体指针，可细分为指向结构体变量的指针和指向结构体数组的指针。 指向结构体变量的指针前面我们通过“结构体变量名.成员名”的方式引用结构体变量中的成员，除了这种方法之外还可以使用指针。 前面讲过，&amp;student1 表示结构体变量 student1 的首地址，即 student1 第一个项的地址。如果定义一个指针变量 p 指向这个地址的话，p 就可以指向结构体变量 student1 中的任意一个成员。 那么，这个指针变量定义成什么类型呢？只能定义成结构体类型，且指向什么结构体类型的结构体变量，就要定义成什么样的结构体类型。比如指向 struct STUDENT 类型的结构体变量，那么指针变量就一定要定义成 struct STUDENT* 类型。 下面将前面的程序用指针的方式修改一下： 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;string.h&gt;struct AGE{ int year; int month; int day;};struct STUDENT{ char name[20]; //姓名 int num; //学号 struct AGE birthday; //生日 float score; //分数};int main(void){ struct STUDENT student1; /*用struct STUDENT结构体类型定义结构体变量student1*/ struct STUDENT *p = NULL; /*定义一个指向struct STUDENT结构体类型的指针变量p*/ p = &amp;student1; /*p指向结构体变量student1的首地址, 即第一个成员的地址*/ strcpy((*p).name, &quot;小明&quot;); //(*p).name等价于student1.name (*p).birthday.year = 1989; (*p).birthday.month = 3; (*p).birthday.day = 29; (*p).num = 1207041; (*p).score = 100; printf(&quot;name : %s\\n&quot;, (*p).name); //(*p).name不能写成p printf(&quot;birthday : %d-%d-%d\\n&quot;, (*p).birthday.year, (*p).birthday.month, (*p).birthday.day); printf(&quot;num : %d\\n&quot;, (*p).num); printf(&quot;score : %.1f\\n&quot;, (*p).score); return 0;} 输出结果是： name : 小明 birthday : 1989-3-29 num : 1207041 score : 100.0 我们看到，用指针引用结构体变量成员的方式是： (*指针变量名).成员名 注意，p 两边的括号不可省略，因为成员运算符“.”的优先级高于指针运算符“”，所以如果 *p 两边的括号省略的话，那么 *p.num 就等价于 *(p.num) 了。 从该程序也可以看出：因为指针变量 p 指向的是结构体变量 student1 第一个成员的地址，即字符数组 name 的首地址，所以 p 和 (*p).name 是等价的。 但是，“等价”仅仅是说它们表示的是同一个内存单元的地址，但它们的类型是不同的。指针变量 p 是 struct STUDENT* 型的，而 (p).name 是 char 型的。所以在 strcpy 中不能将 (*p).name 改成 p。用 %s 进行输入或输出时，输入参数或输出参数也只能写成 (*p).name 而不能写成 p。 同样，虽然 &amp;student1 和 student1.name 表示的是同一个内存单元的地址，但它们的类型是不同的。&amp;student1 是 struct STUDENT* 型的，而 student1.name 是 char* 型的，所以在对 p 进行初始化时，“p=&amp;student1；”不能写成“p=student1.name”。因为 p 是 struct STUDENT* 型的，所以不能将 char* 型的 student1.name 赋给 p。 此外为了使用的方便和直观，用指针引用结构体变量成员的方式： (*指针变量名).成员名 可以直接用： 指针变量名-&gt;成员名 来代替，它们是等价的。“-&gt;”是“指向结构体成员运算符”，它的优先级同结构体成员运算符“.”一样高。p-&gt;num 的含义是：指针变量 p 所指向的结构体变量中的 num 成员。p-&gt;num 最终代表的就是 num 这个成员中的内容。 下面再将程序用“-&gt;”修改一下： 1234567891011121314151617181920212223242526272829303132# include &lt;stdio.h&gt;# include &lt;string.h&gt;struct AGE{ int year; int month; int day;};struct STUDENT{ char name[20]; //姓名 int num; //学号 struct AGE birthday; /*用struct AGE结构体类型定义结构体变量birthday, 生日*/ float score; //分数};int main(void){ struct STUDENT student1; /*用struct STUDENT结构体类型定义结构体变量student1*/ struct STUDENT *p = NULL; /*定义struct STUDENT结构体类型的指针变量p*/ p = &amp;student1; /*p指向结构体变量student1的首地址, 即第一项的地址*/ strcpy(p-&gt;name, &quot;小明&quot;); p-&gt;birthday.year = 1989; p-&gt;birthday.month = 3; p-&gt;birthday.day = 29; p-&gt;num = 1207041; p-&gt;score = 100; printf(&quot;name : %s\\n&quot;, p-&gt;name); //p-&gt;name不能写成p printf(&quot;birthday : %d-%d-%d\\n&quot;, p-&gt;birthday.year, p-&gt;birthday.month, p-&gt;birthday.day); printf(&quot;num : %d\\n&quot;, p-&gt;num); printf(&quot;score : %.1f\\n&quot;, p-&gt;score); return 0;} 输出结果是： name : 小明 birthday : 1989-3-29 num : 1207041 score : 100.0 但是要注意的是，只有“指针变量名”后面才能加“-&gt;”，千万不要在成员名如 birthday 后面加“-&gt;”。 综上所述，以下 3 种形式是等价的： 结构体变量.成员名。 (*指针变量).成员名。 指针变量-&gt;成员名。 其中第 3 种方式很重要，通常都是使用这种方式，另外两种方式用得不多。后面讲链表的时候用的也都是第 3 种方式。 指向结构体数组的指针在前面讲数值型数组的时候可以将数组名赋给一个指针变量，从而使该指针变量指向数组的首地址，然后用指针访问数组的元素。结构体数组也是数组，所以同样可以这么做。 我们知道，结构体数组的每一个元素都是一个结构体变量。如果定义一个结构体指针变量并把结构体数组的数组名赋给这个指针变量的话，就意味着将结构体数组的第一个元素，即第一个结构体变量的地址，也即第一个结构变量中的第一个成员的地址赋给了这个指针变量。比如： 1234567891011121314# include &lt;stdio.h&gt;struct STU{ char name[20]; int age; char sex; char num[20];};int main(void){ struct STU stu[5] = {{&quot;小红&quot;, 22, 'F', &quot;Z1207031&quot;}, {&quot;小明&quot;, 21, 'M', &quot;Z1207035&quot;}, {&quot;小七&quot;, 23, 'F', &quot;Z1207022&quot;}}; struct STU *p = stu; return 0;} 此时指针变量 p 就指向了结构体数组的第一个元素，即指向 stu[0]。我们知道，当一个指针指向一个数组后，指针就可以通过移动的方式指向数组的其他元素。 这个原则对结构体数组和结构体指针同样适用，所以 p+1 就指向 stu[1] 的首地址；p+2 就指向 stu[2] 的首地址……所以只要利用 for 循环，指针就能一个个地指向结构体数组元素。 同样需要注意的是，要将一个结构体数组名赋给一个结构体指针变量，那么它们的结构体类型必须相同。 下面编写一个程序： 123456789101112131415161718# include &lt;stdio.h&gt;struct STU{ char name[20]; int age; char sex; char num[20];};int main(void){ struct STU stu[3] = {{&quot;小红&quot;, 22, 'F', &quot;Z1207031&quot;}, {&quot;小明&quot;, 21, 'M', &quot;Z1207035&quot;}, {&quot;小七&quot;, 23, 'F', &quot;Z1207022&quot;}}; struct STU *p = stu; for (; p&lt;stu+3; ++p) { printf(&quot;name:%s; age:%d; sex:%c; num:%s\\n&quot;, p-&gt;name, p-&gt;age, p-&gt;sex, p-&gt;num); } return 0;} 输出结果是： name:小红; age:22;sex:F; num:Z1207031 name:小明; age:21; sex:M; num:Z1207035 name:小七; age:23; sex:F; num:Z1207022 此外同前面“普通数组和指针的关系”一样，当指针变量 p 指向 stu[0] 时，p[0] 就等价于 stu[0]；p[1] 就等价于 stu[1]；p[2] 就等价于 stu[2]……所以 stu[0].num 就可以写成 p[0].num，其他同理。下面将上面的程序用 p[i] 的方式修改一下： 12345678910111213141516171819# include &lt;stdio.h&gt;struct STU{ char name[20]; int age; char sex; char num[20];};int main(void){ struct STU stu[3] = {{&quot;小红&quot;, 22, 'F', &quot;Z1207031&quot;}, {&quot;小明&quot;, 21, 'M', &quot;Z1207035&quot;}, {&quot;小七&quot;, 23, 'F', &quot;Z1207022&quot;}}; struct STU *p = stu; int i = 0; for (; i&lt;3; ++i) { printf(&quot;name:%s; age:%d; sex:%c; num:%s\\n&quot;, p[i].name, p[i].age, p[i].sex, p[i].num); } return 0;} 输出结果是：name:小红; age:22; sex:F; num:Z1207031 name:小明; age:21; sex:M; num:Z1207035 name:小七; age:23; sex:F; num:Z1207022","link":"/2021/08/10/%E6%8C%87%E9%92%88/"},{"title":"输入网址之后的种种","text":"在学习了部分网络知识后，我们可以大致的想象到在键入网址后，到网页显示出对应内容，其间发生了什么 接下来以简单的网络拓扑模型作为例子，探究一个数据包在网络中发生的种种。 HTTP浏览器做的第一步工作是解析 URL 首先浏览器做的第一步工作就是要对 URL 进行解析，从而生发送给 Web 服务器的请求信息。 让我们看看一条长长的 URL 里的各个元素的代表什么，见下图： 所以图中的长长的 URL 实际上是请求服务器里的文件资源。 要是上图中的蓝色部分 URL 元素都省略了，哪应该是请求哪个文件呢？ 当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html 这些文件，这样就不会发生混乱了。 生产 HTTP 请求信息对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。 真实地址查询 —— DNS通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。 但在发送之前，还有一项工作需要完成，那就是查询服务器域名对于的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。 比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。 所以，有一种服务器就专门保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。 域名的层级关系DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。 在域名中，越靠右的位置表示其层级越高。 毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。 根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。 所以域名的层级关系类似一个树状结构： 根 DNS 服务器 顶级域 DNS 服务器（com） 权威 DNS 服务器（server.com） 根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。 这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。 因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。 域名解析的工作流程 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。” 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？” 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。 至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。 协议栈通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。 协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。 应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。 协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据刽被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。 此外 IP 中还包括 ICMP 协议和 ARP 协议。 ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。 ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。 IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。 可靠传输 —— TCPHTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。 TCP 包头格式我们先看看 TCP 报文头部的格式： 首先，源端口号和目标端口号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。 接下来有包的序号，这个是为了解决包乱序的问题。 还有应该有的是确认号，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。 接下来还有一些状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。 还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。 除了做流量控制以外，TCP还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。 TCP 传输数据之前，要先三次握手建立连接在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为三次握手。 这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。 然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。 服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。 客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。 服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。 所以三次握手目的是保证双方都有发送和接收的能力。 如何查看 TCP 的连接状态？TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。 TCP 分割数据如果 HTTP 请求消息比较长，超过了 MSS 的长度，这时 TCP 就需要把 HTTP 的数据拆解一块块的数据发送，而不是一次性发送所有数据。 MTU：一个网络包的最大长度，以太网中一般为 1500 字节。 MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。 数据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。 TCP 报文生成TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80， HTTPS 默认端口号是 443）。 在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。 至此，网络包的报文如下图: 远程定位 —— IPTCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。 IP 包头格式我们先看看 IP 报文头部的格式： 在 IP 协议里面需要有源地址 IP 和 目标地址 IP： 源地址IP，即是客户端输出的 IP 地址； 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。 因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06（十六进制），表示协议为 TCP。 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。 这个时候就需要根据路由表规则，来判断哪一个网卡作为源地址 IP。 在 Linux 操作系统，我们可以使用 route -n 命令查看当前系统的路由表。 举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 192.168.10.200。 首先先和第一条条目的子网掩码（Genmask）进行 与运算，得到结果为 192.168.10.0，但是第一个条目的 Destination 是 192.168.3.0，两者不一致所以匹配失败。 再与第二条目的子网掩码进行 与运算，得到的结果为 192.168.10.0，与第二条目的 Destination 192.168.10.0 匹配成功，所以将使用 eth1 网卡的 IP 地址作为 IP 包头的源地址。 那么假设 Web 服务器的目标地址是 10.100.20.100，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。 第三条目比较特殊，它目标地址和子网掩码都是 0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，Gateway 即是路由器的 IP 地址。 IP 报文生成至此，网络包的报文如下图: 两点传输 —— MAC生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。 MAC 包头格式MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。 在 MAC 包头里需要发送方 MAC 地址和接收方目标 MAC 地址，用于两点之间的传输。 一般在 TCP/IP 通信里，MAC 包头的协议类型只使用： 0800 ：IP 协议 0806 ：ARP 协议 MAC 发送方和接收方如何确认?发送方的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。 接收方的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。 所以先得搞清楚应该把包发给谁，这个只要查一下路由表就知道了。在路由表中找到相匹配的条目，然后把包发给 Gateway 列中的 IP 地址就可以了。 既然知道要发给谁，按如何获取对方的 MAC 地址呢？不知道对方 MAC 地址？不知道就喊呗。 此时就需要 ARP 协议帮我们找到路由器的 MAC 地址。 ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。 然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。 如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。 每次都要广播获取，这不是很麻烦吗？放心，在后续操作系统会把本次查询结果放到一块叫做 ARP 缓存的内存空间留着以后用，不过缓存的时间就几分钟。 也就是说，在发包时： 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。 查看 ARP 缓存内容在 Linux 系统中，我们可以使用 arp -a 命令来查看 ARP 缓存的内容。 MAC 报文生成至此，网络包的报文如下图: 出口 —— 网卡IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。 负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。 网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。 起始帧分界符是一个用来表示包起始位置的标记 末尾的 FCS（帧校验序列）用来检查包传输过程是否有损坏 最后网卡会将包转为电信号，通过网线发送出去。 送别者 —— 交换机下面来看一下包是如何通过交换机的。交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为二层网络设备。 交换机的包接收操作首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。 然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。 计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址。 将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。 交换机的 MAC 地址表主要包含两个信息： 一个是设备的 MAC 地址， 另一个是该设备连接在交换机的哪个端口上。 举个例子，如果收到的包的接收方 MAC 地址为 00-02-B3-1C-9C-F9，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 3 号端口上，然后就可以通过交换电路将包发送到相应的端口了。 所以，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。 当 MAC 地址表找不到指定的 MAC 地址会怎么样？地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。 这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。 这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。 有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？” 其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。 局域网中每秒可以传输上千个包，多出一两个包并无大碍。 此外，如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。 以下两个属于广播地址： MAC 地址中的 FF:FF:FF:FF:FF:FF IP 地址中的 255.255.255.255 出境大门 —— 路由器 路由器与交换机的区别网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。 这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。 不过在具体的操作过程上，路由器和交换机是有区别的。 因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址； 而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。 路由器基本原理路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。 当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。 路由器的包接收操作首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进行错误校验。 如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。 总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。 查询路由表确定输出端口完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。 MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。 接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。 转发操作分为几个阶段，首先是查询路由表判断转发目标。 具体的工作流程根据上图，举个例子。 假设地址为 10.10.1.101 的计算机要向地址为 192.168.1.100 的服务器发送一个包，这个包先到达图中的路由器。 判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。 路由匹配和前面讲的一样，每个条目的子网掩码和 192.168.1.100 IP 做 &amp; 与运算后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。 如第二条目的子网掩码 255.255.255.0 与 192.168.1.100 IP 做 &amp; 与运算后，得到结果是 192.168.1.0 ，这与第二条目的目标地址 192.168.1.0 匹配，该第二条目记录就会被作为转发目标。 实在找不到匹配路由时，就会选择默认路由，路由表中子网掩码为 0.0.0.0 的记录表示「默认路由」。 路由器的发送操作接下来就会进入包的发送操作。 首先，我们需要根据路由表的网关列判断对方的地址。 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。 知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。 路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。 接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 0080 （十六进制）表示 IP 协议。 网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。 发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。 接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。 不知你发现了没有，在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。 互相扒皮 —— 服务器 与 客户端数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？ 服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？ 数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。 接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。 于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。 于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。 服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。 HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。 穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。 最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。 客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！ 于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！ 最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。","link":"/2021/08/13/%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E7%A7%8D%E7%A7%8D/"},{"title":"c语言程序设计","text":"C语言复习过程：1.看基础视频，过一遍王敬华的C语言PPT，对C语言可能涉及的内容有个整体的了解；2.看王敬华的C语言教材，C语言教材一定要用王敬华的，最近几年很多真题出自王敬华教材，这本教材必须做的烂熟；3.做王敬华给本科生的题库，做官方渠道传出的C复习题，做本科生C语言实验课题和期末上机题库；4.看C语言详细笔记做最后巩固，翻看往年真题；5.对知识点做一个完整的回顾；6.最后对上述做的题，做一个错题集，在考前有针对性地看下。 1、各种运算符、优先级和结合性运算符优先级和结合性一览表 上表中可以总结出如下规律： 结合方向只有三个是从右往左，其余都是从左往右。 所有双目运算符中只有赋值运算符的结合方向是从右往左。 另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。 C语言中有且只有一个三目运算符。 逗号运算符的优先级最低，要记住。 此外要记住，对于优先级：算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 赋值运算符。逻辑运算符中“逻辑非 !”除外。 一些容易出错的优先级问题上表中，优先级同为1 的几种运算符如果同时出现，那怎么确定表达式的优先级呢？下表就整理了这些容易出错的情况： 2、数据类型及与表示范围有符号整数类型 类型名称 字节数 取值范围 signed char 1 -27 (-128) ~ 27-1 (127) short int 或 short 2 -215 (-32 768) ~ 215-1 (32 767) int 4 -231 (-2 147 483 648) ~ 231-1(2 147 483 647) long int 或 long 4 -231 (-2 147 483 648) ~ 231-1 (2 147 483 647) long long int 或 long long 8 -263 (-9.2233720368548e+18) ~ 263-1 (9.2233720368548e+18) 无符号整数类型 类型名称 字节数 取值范围 unsigned char 1 0 ~ 28-1 (255) unsigned short int 或 unsigned short 2 0 ~ 216-1 (65 535) unsigned int 4 0 ~ 232-1 (4 294 967 295) unsigned long int 或 unsigned long 4 0 ~ 232-1 (4 294 967 295) unsigned long long int 或 unsigned long long 8 0 ~ 264-1 (1.844674407371e+19) 浮点类型 类型名称 字节数 取值范围 float 4 -/+3.4e38（精确到6位小数） double 8 -/+1.7e308（精确到15位小数） long double 12 -/+1.19e4932（精确到18位小数） 3、格式化输入、输出格式化输入——scanf函数具有变长参数表的函数scanf的声明形式如下： int scanf(char *format, ...) scanf函数从标准输入中读取字符序列，按照format中的格式说明对字符序列进行解释，并把结果保存到其余的参数中。其他所有参数必须是指针，用于指定经格式转换后的相应输入保存的位置。 当scanf函数扫描完其格式串，或者碰到某些输入无法与格式控制说明匹配的情况时，该函数将终止，同时，成功匹配并赋值的输入项的个数将作为函数值返回，所有，该函数的返回值可以用来确定已匹配的输入项的个数。如果到达文件的结尾，该函数将返回EOF。注意，返回EOF与0是不同的，0表示下一个输入字符与格式串中的第一个格式说明不匹配。下一次调用scanf函数将从上一次转换的最后一个字符的下一个字符s开始继续搜索。 另外还有一个输入函数sscanf,它用于从一个字符串(而不是标准输入)中读取字符序列: int sscanf(char *string, char *format, arg1, arg2...) 它按照格式参数format中规定的格式扫描字符串string,并把结果分别保存到arg1、Iarg2、..这些参数中。这些参数必须是指针。 格式串通常都包含转换说明，用于控制输入的转换。格式串可能包含下列部分: 空格或制表符，在处理过程中将被忽略。 普通字符(不包括%)，用于匹配输入流中下一个非空白符字符。 转换说明，依次由一个%、一个可选的赋值禁止字符*、一个可选的数值(指定最大字段宽度)、一个可选的h、1或L字符(指定目标对象的宽度)以及一个转换字符组成。 转换说明控制下一个输入字段的转换。一般来说，转换结果存放在相应的参数指向的变量中。但是，如果转换说明中有赋值禁止字符*，则跳过该输入字段，不进行赋值。输入字段定义为一个不包括空白符的字符串，其边界定义为到下一个空白符或达到指定的字段宽度。这表明scanf函数将越过行边界读取输入，因为换行符也是空白符。(空白符包括空格符、横向制表符、换行符、回车符、纵向制表符以及换页符)。 转换字符指定对字段的解释。对应的参数必须时指针，这也是C语言通过值调用语义所要求的。 转换说明d、i、o、u及x的前面可以加上字符h或l。前缀h表明参数表的相应参数是一个指向short类型而非int类型的指针,前缀l表明参数表的相应参数是一个指向long类型的指针。类似地，转换说明e、f和g的前面也可以加上前缀l,它表明参数表的相应参数是一个指向double类型而非float类型的指针。 格式化输出——printf函数输出函数printf将内部数值转换为字符的形式。 int printf (char *format, arg1,arg2, ...); 函数printf在输出格式format的控制下，将其参数进行转换与格式化，并在标准输出设备上打印出来。它的返回值为打印的字符数。 格式字符串包含两种类型的对象:普通字符和转换说明。在输出时，普通字符将原样不动地复制到输出流中，而转换说明并不直接输出到输出流中，而是用于控制printf中参数的转换和打印，每个转换说明都由一个百分号字符(即%)开始，并以一个转换字符结束。在字符%和转换字符中间可能依次包含下列组成部分: 负号，用于指定被转换的参数按照左对齐的形式输出。 数，用于指定最小字段宽度。转换后的参数将打印不小于最小字段宽度的字段。如果有必要，字段左边(如果使用左对齐的方式，则为右边)多余的字符位置用空格填充以保证最小字段宽。 小数点，用于将字段宽度和精度分开。 数，用于指定精度，即指定字符串中要打印的最大字符数、浮点数小数点后的位数、整型最少输出的数字数目。 字母h或l，字母h表不将整数l作为short类l型打印，字母l表示将整数作为long类型打印。 下表说明了在打印字符串”hello, world” (12个字符)时根据不同的转换说明产生的不同结果。我们在每个字段的左边和右边加上冒号，这样可以清晰地表示出字段的宽度。 :%s: &nbsp;&nbsp; &nbsp; &nbsp;:hello, world: :%10s: &nbsp; &nbsp;:hello, world: :%.10s: &nbsp; &nbsp;:hello, wor: :%-10s: &nbsp; &nbsp;:hello, world: :%.15s: &nbsp; &nbsp;:hello, world: :%-15s: &nbsp; &nbsp;:hello, world : :%15.10s: &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp;hello, wor:(与下列o对齐) :%-15.10s: &nbsp;:hello, wor : 函数sprintf执行的转换和函数printf相同，但它将输出保存到一个字符串中: int sprintf (char. *string, char *format, arg1， arg2, ... ) sprintf函数和printf函数一样，按照format格式格式化参数序列arg1、arg2、但它将输出结果存放到str ing中，而不是输出到标准输出中。当然，string必须足够大以存放输出结果。 4、程序的控制结构及应用程序结构：在C语言程序中，一共有三种程序结构：顺序结构、选择结构(分支结构)、循环结构； 顺序结构：从头到尾一句接着一句的执行下来，直到执行完最后一句； 选择结构：到某个节点后，会根据一次判断的结果来决定之后向哪一个分支方向执行； 循环结构：循环结构有一个循环体，循环体里是一段代码。对于循环结构来说，关键在于根据判断的结果，来决定循环体执行多少次； 注：在逻辑上有一种bool类型(也叫boolean类型，布尔类型)，只有两个值，即真和假。C语言的判断表达式最终的值就是一个bool类型，这个判断表达式的bool值就决定了选择结构如何选择，循环结构如何循环； 顺序结构：顺序结构很简单，一般我们遇到的除了选择结构和循环结构外，都是顺序结构； 选择结构：C语言中常用的选择结构主要有以下两种： (1) if else：引入关键字：if else else if123456789101112131415161718192021 if (bool值) // 如果bool值为真，则执行代码段1，否则执行代码段2 { 代码段1 } else { 代码段2 } if (bool值1) // 如果bool值1为真，则执行代码段1，否则判断bool值2是否为真 { 代码段1 } else if (bool值2) // 若bool值2为真则执行代码段2，否则直接执行代码段3 { // 开头的if和结尾的else都只能有一个，但是中间的else if可以有好多个 代码段2 } else { 代码段3 } (2) switch case：引入关键字：switch case break default12345678910111213141516 switch (变量) // 执行到这一句时，变量的值是已知的 { // switch case语句执行时，会用该变量的值依次与各个case后的常数去对比，试图找到第一个匹配项，找到匹配的项目后， case 常数1: // 就去执行该case对应的代码段，如果没找到则继续下一个case，直到default 代码段1; // 如果前面的case都未匹配，则default匹配。 break; case 常数2: 代码段2; break; …… default: 代码段n; break; } 注：第一，case中必须是常数，而且必须是整形； 第二，一般来说，每个case中代码段后都必须有一个break； 第三，case之后一般都会有default，虽然语法上允许没有default，但是建议写代码时一定要写； (3) if else和switch case的区别：if else适合对比条件较复杂，但是分支比较少的情况，switch case适合那种对比条件简单，但是分支较多的情况； 通常的做法是：在适合使用switch case的情况下会优先使用switch case，如果不适合则使用if else； 循环结构：C语言中常用的循环结构主要有以下三种： (1) for：1234 for (循环控制变量初始化; 循环终止条件; 循环控制变量增量) { 循环体 } 循环执行步骤： 第一，先进行循环控制变量初始化； 第二，执行循环终止条件，如果判断结果为真，则进入第三步；如果为假则循环终止并退出； 第三，执行循环体； 第四，执行循环控制变量增量，转入第二步； 注：for循环()中的三部分除了循环终止条件外，其他两部分都可以省略，但标准的for循环中，应该把循环控制变量的初始化，增量都放在()当中，并且在循环体中绝对不应该更改循环控制变量； (2) while：12345678910 循环控制变量初始化 while(循环终止条件) { 循环体 循环控制变量增量 } 循环执行步骤： 第一，先进行循环控制变量初始化(在while之前)； 第二，判断循环终止条件，如果判断结果为真，则进入第三步；如果为假则不执行循环体； 第三，执行循环体； 第四，执行循环控制变量增量，转入第二步； (3) do while：循环执行步骤：第一，先进行循环控制变量初始化(在do while之前)； 第二，执行循环体； 第三，执行循环控制变量增量； 第四，判断循环终止条件，如果判断结果为真，则返回第二步；如果为假则直接退出循环； (4) 总结：不管哪种循环结构，都不能缺少循环控制条件初始化，终止条件，循环控制变量增量，循环体这四部分； while循环是先判断后执行，do while循环是先执行后判断，等循环一次之后，其实都是一样的； 5、函数参数的传递方式函数参数传递三种方式（传值方式，地址传递，引用传递） 形参与实参形参即形式上的参数，对实参的一种抽象类型描述只是声明一个函数能够接受什么类型的实参，而不确定接受的实参的具体内容是什么 实参即传递给函数对应形参的具体内容 参数传递两种方式–传值&amp;传址传值方式：将实参的值拷贝给函数或方法，在函数内对形参进行操作，操作的对象是实参的拷贝，对实参本身没有影响，在函数结束返回后，形参被丢弃释放，实参的内容不会被改变 传址方式：将实参的地址传递给函数，在函数内对形参进行操作等同于对实参进行相同的操作，在函数调用结束返回后，形参被释放，实参的内容是对形参进行操作后的结果。传址又分为：引用传递&amp;指针传递 1.值传递1234567void exchange1(int x,int y){ int temp; temp=x; x=y; y=temp;} exchange1(a,b);在调用过程中，函数隐含的把实参a,b的值分别传给了x,y 函数中的操作只是对，xy的操作，没有对a,b 进行任何操作，因此啊，ab的值是不变的。 2.地址传递（指针）123456789void exchange2(int *px,int *py){ int temp=*px; *px=*py; *py=temp;}int a=4,b=5;exchange2(&amp;a,&amp;b); 将ab的地址传递给函数，对*px,*py的操作即是对a,b变量本身的操作。可以实现a,b的值交换 3.引用传递12345678void exchange3(int &amp;x,int &amp;y){ int temp=x; x=y; y=temp;}int a=3,b=4;exchange3(a,b); 仅形式参数的格式与值传递不同，内部定义域调用与值传递完全相同，可以实现ab值得对调 因为在x,y 前有一个取地址符号&amp;，在调用exchang3(a,b)时会用替换x,y,称xy引用了变量ab,在函数内部便是对实参ab进行操作了，函数 内部可以直接修改a,b的值。 引用即对象的别名，传对象的引用，用于把一个对象的地址作为参数传递过去，而不是对象本身。引用传递，避免了一次实参到形参的拷贝，提高了效率。 引用，指针，传址使用原则 如果数据对象较小，如内置数据类型或小型结构，则按值传递 如果数据对象是数组，则使用指针，并将指针声明为指向const的指针 如果数据对象是较大的结构，则使用const指针或const引用，以提高运行效率，以减少复制结构所需要的时间和空间 如果数据对象是类对象，则使用const引用，传递类对象参数的标准方式是按引用传递。 如果出现类似的manmin(&amp;x),其中x为int类型的值，那么函数将修改变量x的值。 6、变量的作用域与生存期作用域作用域描述了程序中可以访问一个标识符的一个或多个区域，一个C变量的作用域可以是代码块作用域、函数原型作用域，或者文件作用域。代码块是包含在一对花括号`内的一段代码，在代码块中定义的变量具有代码块作用域，从该变量被定义的地方到包含该定义的代码块的末尾该变量均可见，但只局限于代码块。因此，函数作用域也属于代码块作用域。 一个在所有函数之外定义的变量具有文件作用域，从定义开始到包含该文件结尾都可见，文件作用域变量也称为全局变量。 生存期一个C变量有两种生存期：静态生存期和自动生存期。一个静态变量在程序执行期间将一直存在，一个自动变量在作用域结束后内存将释放。 一般使用 static 声明变量的静态生存期，而对于文件作用域变量，都具有静态生存期。 123456789101112131415161718#include &lt;stdio.h&gt;int lint = 1; // lint 具有文件作用域、静态生存期void print(int data){ int i, *p; // 作用域开始，局部变量 for(i=0; i&lt;lint; i++) { static int temp = 1; // 具有代码块作用域、静态生存期 int pd = data * i; // pd作用域开始 . . . temp++; p = &amp;temp; // p指向temp所在地址 printf(“data = %d\\t”, pd); } // pd作用域结束 . . . // printf(“temp = %s\\n”, temp); // 错误，temp 已离开作用域 printf(“temp = %s\\n”, *p); // 正确，temp 不可见，但是一直存在，其地址也可用} // i 作用域结束 1.具有代码块作用域的静态变量未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非被显示初始化）。 在调用包含具有代码块作用域静态变量的函数时，由于其一直存在，因此在每次调用时print（）函数时，其它自动变量都被初始化，而temp只在编译print（）时初始化一次。 123456789int main(void){ int c; for(c=0;c&lt;=3;c++) { print(1); } return 0;} 返回下列结果 data = 1 temp = 2 data = 1 temp = 3 data = 1 temp = 4 2.返回字符串的函数在调用返回字符串的函数时，有时候返回的是垃圾信息。例如下面的程序 123456char *itoa(int n){ char retbuf[20]; // 错！ sprintf(retbuf, &quot;%d&quot;, n); return retbuf; // 错！} 因为局部数组在函数调用完成之后，堆栈的空间将释放，因而返回指向数组的指针无效。 一种解决方案是把缓冲区声明成静态生存期，这样在程序运行期间局部数组将一直存在 static char retbuf[20]; 另一种解决方案是使用 malloc申请动态内存空间 char * retbuf = malloc(20); 虽然指针retbuf 是局部变量，离开调用函数后将被释放，但是申请的内存空间在没有使用 free之前将一直存在。因此也可能产生了一个问题：申请的内存空间没有被释放，可行的方法是用完返回的字符指针之后，使用free将该地址处的内存释放，前提是这个指针没有移动。 3.static 与全局变量由于全局变量自动具有静态生存期，在全局变量之前加上 static，表示全局变量的链接方式。 具有外部链接的全局变量，其他文件可以使用；具有部链接的全局变量，属于文件私有，但是可以被该文件中的任一函数使用。为了使程序更加清晰，可以在使用全局变量的函数中通过使用关键字extern 来再次声明它。 123456789// file1.cint giant = 5; // 全局变量，外部链接static int dodg = 3; // 全局变量，内部链接int main(void){ extern int giant; // 可选的声明 extern int dodg; // 可选的声明 . . .} 如果变量是在别的文件中定义的，使用 extern来声明该变量是必须的。其它文件中引用声明 123456789// file2.cstatic int dodg = 3; // 可以int giant = 5; // 命名冲突，在file1.c中已经定义了 int main(void){ extern int giant; // 必须的声明 // extern int dodg; // 错误的声明，因为dodg为内部链接 . . .} 两个具有相同名称的外部对象实际上代表的是同一个对象，当在两个不同源文件中都包括了一个相同的定义，那么这将表示程序错误（如果连接器禁止外部变量重复定义的话），或者两个源文件共享同一个实例。为了避免这类命名冲突的问题，static是一个有用的工具。 注意：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。 4.静态函数在函数的返回类型前加上关键字static，函数就被定义成为静态函数。 函数的定义和声明默认情况下是extern的，与具有内部链接的全局变量一样，静态函数只是在声明它的文件当中可见，不能被其他文件所用。例如 123456789// file1.cvoid dis();static void static_dis(); int main(){ dis(); static_dis(); renturn 0;} 12345678910// file2.c void dis(){ static_dis();}static void static_dis(){ printf(&quot;static_dis() of file2.c has been called/n&quot;);} 文件分别编译通过，但是连接的时候找不到函数static_dis（）的定义，产生错误。 定义静态函数的好处：其他文件中可以定义相同名字的函数，不会发生冲突 7、变量的存储类型在C语言中，对变量的存储类型说明有以下四种： auto 自动变量 register &nbsp;&nbsp;寄存器变量 extern 外部变量 static &nbsp; 静态变量 自动变量和寄存器变量属于动态存储方式，外部变量和静态变量属于静态存储方式。 在介绍了变量的存储类型之后，可以知道对一个变量的说明不仅应说明其数据类型，还应说明其存储类型。 因此变量说明的完整形式应为：存储类型说明符数据类型说明符变量名，变量名…；例如： static int a,b; 说明a,b为静态类型变量 auto char c1,c2; 说明c1,c2为自动字符变量 static int a[5]={1,2,3,4,5}; 说明a为静整型数组 extern int x,y; 说明x,y为外部整型变量 下面分别介绍以上四种存储类型： 一、自动变量的类型说明符为auto（缺省的符号，不写就是默认auto） 这种存储类型是C语言程序中使用最广泛的一种类型。C语言规定，函数内凡未加存储类型说明的变量均视为自动变量，也就是说自动变量可省去说明符auto。 自动变量的作用域仅限于定义该变量的个体内。在函数中定义的自动变量，只在该函数内有效。在复合语句中定义的自动变量只在该复合语句中有效。 自动变量属于动态存储方式，只有在使用它，即定义该变量的函数被调用时才给它分配存储单元，开始它的生存期。函数调用结束，释放存储单元，结束生存期。因此函数调用结束之后，自动变量的值不能保留。在复合语句中定义的自动变量，在退出复合语句后也不能再使用，否则将引起错误。 由于自动变量的作用域和生存期都局限于定义它的个体内(函数或复合语句内)，因此不同的个体中允许使用同名的变量而不会混淆。即使在函数内定义的自动变量也可与该函数内部的复合语句中定义的自动变量同名。 二、外部变量的类型说明符为extern 1.外部变量和全局变量是对同一类变量的两种不同角度的提法。全局变量是从它的作用域提出的，外部变量从它的存储方式提出的，表示了它的生存期。 2.当一个源程序由若干个源文件组成时，在一个源文件中定义的外部变量在其它的源文件中也有效。 三、静态变量static1、静态局部变量静态局部变量属于静态存储方式，它具有以下特点： 静态局部变量在函数内定义，但不象自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。 静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。 允许对构造类静态局部量赋初值。在数组一章中，介绍数组初始化时已作过说明。若未赋以初值，则由系统自动赋以0值。 对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。根据静态局部变量的特点，可以看出它是一种生存期为整个源程序的量。虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值。因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，因此仍以采用局部静态变量为宜。 2、静态全局变量 全局变量(外部变量)的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static这个说明符在不同的地方所起的作用是不同的。应予以注意。 四、寄存器变量register 上述各类变量都存放在存储器内，因此当对一个变量频繁读写时，必须要反复访问内存储器，从而花费大量的存取时间。为此，C语言提供了另一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，这样可提高效率。寄存器变量的说明符是register。对于循环次数较多的循环控制变量及循环体内反复使用的变量均可定义为寄存器变量。 只有局部自动变量和形式参数才可以定义为寄存器变量。因为寄存器变量属于动态存储方式。凡需要采用静态存储方式的量不能定义为寄存器变量。 在Turbo C，MS C等微机上使用的C语言中，实际上是把寄存器变量当成自动变量处理的。因此速度并不能提高。而在程序中允许使用寄存器变量只是为了与标准C保持一致。3.即使能真正使用寄存器变量的机器，由于CPU中寄存器的个数是有限的，因此使用寄存器变量的个数也是有限的。 8、递归函数C语言中的函数可以递归调用，即函数可以直接或间接调用自身。我们考虑下将一个数作为字符串打印的情况。前面讲过，数字是以反序生成的:低位数字先于高位数字生成，但它们必须以与此相反的次序打印。 解决该问题有两种方法。一种方法是将生成的各个数字依次存储到一个数组中，然后再以相反的次序打印它们，这种方式与3.6节中itoa函数的处理方式相似。另一种方法则是使用递归，函数printd首先调用它自身打印前面的(高位)数字，然后再打印后面的数字。这里编写的函数不能处理最大的负数。 1234567891011121314#include &lt;stdio.h&gt;/*printd:printnin decimal */void printd(int n){ if(n&lt;O){ putchar('-'); n =- n; } if(n/10) printd(n /10); putchar(n % 10 + '0'):} 函数递归调用自身时，每次调用都会得到一个与以前的自动变量集合不同的新的自动变量集合。因此，调用printd(123)时，第一次调用printd的参数n=123.它把12传递给printa的第二次调用，后者又把1传递结printd的第三次调用。第三次调用printd时首先将打印1.然后再返回到第二次调用。从第三次调用返回后的第二次调用同样也将先打印2，然后再返回到第一次调用。返回到第一次调用时将打3,随之结束函数的执行。 另外一个能较好说明递归的例子是快速排序.快速排序算法是C.A R. Hoare于1962年发明的。对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集，一个子集中的所有元紧都小于该元索，另一个子集中的所有元素都大于或等于该元素。对这样两个子集递归执行这一过程，当某个子集中的元素数小于2时，这个子集就不需要再次排序，终止递归。 从执行速度来讲，下列版本的快速排序函数可能不是最快的，但它是最简单的算法之.在每次划分子集时，该算法总是选取各个子数组的中间元素。 1234567891011121314151617/* qsort: sort v[1eft]...v[right] into increasing order */void qsort(int v[], intleft, int right){ int i, last; void swap(int v[], int i, int j): if (left &gt;= right) /* do nothing if array containg */ return; /*fewer than two elements */ swap(v, left, (left + right)/2); /* move partition elem */ last = left; for (i = left + 1;1 &lt;= right; i++)/* partition * if (v[1] &lt; v[left]) swap(v, ++last,i); swap(v, left, last);/* restore partition elem */ qsort(v, left, last-1); qsort(v, last+1, right);} 这里之所以将数组元素交换操作放在一个单独的函数swap中，是因为它在qsort函数中要使用3次。 12345678910/* swap: interchange v[i] andv[j]*/void swap (intv[]，inti，intj){ int temp; temp =v[i]; V[i]=V[j]]; v[j]=temp;} 标准库中提供了一个qsort函数，它可用于对任何类型的对象排序。 递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈。递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解。在描述树等递归定义的数据结构时使用递归尤其方便。","link":"/2021/08/09/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},{"title":"为什么redis这么快","text":"最近在看复习一些关于redis的知识点，以前只知道它是一个非关系型数据库，适合用来做缓存，并且查询速度很快，但是它为什么这么快呢？ 1.redis是单线程的Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象的时候，这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。而单线程，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 不过这里又引申了一个问题，理论上来说多线程能更好的提高程序的运行效率，那为什么redis单线程还这么快呢？ 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈。 并且redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。 2.使用IO多路复用，非阻塞IO2.1为什么要使用I/O多路复用技术当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，就会阻塞在 accept() 函数，这导致其他客户端无法和 Redis 建立连接。 类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。这就导致 Redis 整个线程阻塞，无法处理。 2.2 什么是IO多路复用技术Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中,内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。下图是IO多路复用的一个大致的模型图。","link":"/2021/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88redis%E8%BF%99%E4%B9%88%E5%BF%AB/"}],"tags":[],"categories":[{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"考研复习","slug":"考研复习","link":"/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"}]}