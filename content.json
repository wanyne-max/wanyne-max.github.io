{"pages":[{"title":"关于我","text":"被酒莫惊春睡重 赌书消得泼茶香 当时只道是寻常","link":"/about/index.html"}],"posts":[{"title":"UTC-UT-GMT  时区和时间戳","text":"格林尼治平时（Greenwich Mean Time），简称 GMT 世界时（Universal Time），简称 UT 协调世界时（Coordinated Universal Time），简称 UTC UTC, UT, GMT 三者出现的先后顺序： GMT -&gt; UT -&gt; UTC，我们可以把 GMT 和 UTC 看作一样的。 GMT 和 UTC 都是用 秒 数来计算的。 时区 全球划分为 24 个时区 时区可以用 UTC 表示，范围为 UTC-12 — UTC-11 — UTC-1 — UTC — UTC-1 — UTC+11 — UTC+12，依次增加 相差多少个时区，就是相差多少个小时 时区可以按 区域/位置 的格式表示，就可以得到一个独有的名称（时区有很多种表示方式） 以 中国时区 为例。 China Standard Time (CST), UTC +8、 无夏令时，全年 UTC 偏移量不变 中国的 IANA 时区标识符为 Asia/Shanghai。 时间戳 时间戳（Timestamp）是指字符串或编码信息用于辨识记录下来的时间日期。国际标准为 ISO 8601 时间戳是从 协调世界时（UTC） 1970 年 1 月 1 日 0 时 0 分 0 秒 起至现在的总秒数，不考虑闰秒 时间戳是用无符号整数表示 时间戳 和 UTC 进行转换，UTC 和 时区 进行转换，因此 时间戳 也可以和 UTC 进行转换 有 秒级（10 位）， 毫秒级（13 位） 的时间戳，也有纳米级（19 位） 的时间戳，如 Java 就可以处理到纳米级 本地时间是指当前操作系统设定的时区。例如北京时区是东8区，则本地时间：2015-04-19 12:20:00 实际上就是UTC+8:00时区的时间：2015-04-19 12:20:00 UTC+8:00 而此刻的格林威治标准时间与北京时间差了8小时，也就是UTC+0:00时区的时间应该是：2015-04-19 04:20:00 UTC+0:00 原文链接：https://blog.csdn.net/zheng_lan_fang/article/details/79448965 因为时区的关系，由于没设置使用者的时区，所以就会看到在一些系统上会出现时间慢了 8 个小时的现象（以北京时区为例） 不同的编程语言可以通过设置的方式来调整时区 不同的编程语言 格式化 时间的方式也不同（如：yyyy-mm-dd hh:mm:ss），为确保统一，我们可以使用时间戳（mysql，Java，JavaScript 存放时间都用 时间戳，就不会产生写入和读出不一致了。","link":"/2021/08/08/UTC-UT-GMT%20%20%E6%97%B6%E5%8C%BA%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3/"},{"title":"blog搭建（记录踩过的坑）","text":"前两天整理资料的时候看到以前准备搭建的博客，想着趁空闲时间试着搞一个。每次搞个什么东西都磨磨蹭蹭的，这次索性直接莽 先是查找了市面上的常见架构，本来贼心动wordpress，但是看着太麻烦，其实是要用服务器太贵，直接放弃 最后选择的是hexo+lcarus搭建静态博客的方法，然后将博客push到github上存储。 （一）搭建环境 1、安装node.js首先要先安装node.js：https://github.com/hexojs/hexo/issues （注意要选择长期支持版 较稳定） 安装较简单，安装目标目录可以自定义，如果C盘较小就换到其他盘 2、安装gitgit 官方网站：https://git-scm.com/ 你如果不会用的话,可以去这个廖雪峰老师的网站: https://www.liaoxuefeng.com/wiki/896043488029600 输入 node -v npm -v git –version看一下版本号，若正常输出则说明成功了 3、创建GitHub Pages (仓库)在你的github主页, ​ 点击右上角 + 号 &gt; New repository ​ Repository name 中输入 你的用户名.github.io(若不这样，则会404) ​ 勾选 “Initialize this repository with a README” ​ Description 选填 点Create repository后你的博客地址就生成了 地址为: https://用户名.github.io （二）安装Hexo 1、安装打开终端 执行 npm install hexo-cli -g 全局安装Hexo. 2、创建博客创建blog文件夹用于存放博客md cd blog 进入博客目录 npm install 安装依赖 执行 npm install hexo-cli -g 全局安装Hexo. hexo s 启动服务 （三）选择主题在blog初始化的时候hexo就默认下载了landscape主题，对比了很多款，我现在正在用的这款是icarus，也可以到hexo的主题列表里面自己选择 https://hexo.io/themes/ 下载 进入博客根目录,打开git bash git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 下载完成之后需要修改配置在blog文件夹下 _config.yml文件 所有配置基本都在这里 找到theme: landscape 修改为theme: icarus 重启服务即可(hexo clean \\ hexo g \\ hexo s). （四）开始记录hexo默认是使用的markdown，执行hexo new 文章名 默认会在./source/_posts/ 文件夹下创建.md文件 同理 也可以把自己已经写好的.md文件放到这个目录下，然后执行 hexo g &amp;&amp; hexo s 打开浏览器就能看到编译好的html了 最后使用hexo d将修改后的内容push到GitHub上 常见问题修改了主题之后执行 hexo server可能会有如下报错 这是因为icarus主题所需的依赖没有安装. 按照提示安装依赖(类似如下) npm install –save bulma-stylus@0.8.0 hexo-component-inferno@^0.4.0 hexo-renderer-inferno@^0.1.3 inferno@^7.3.3 inferno-create-element@^7.3.3 （五）hexo常用命令 clean Remove generated files and cache. config Get or set configurations. deploy Deploy your website. generate Generate static files. help Get help on a command. init Create a new Hexo folder. list List the information of the site migrate Migrate your site from other system to Hexo. new Create a new post. publish Moves a draft post from _drafts to _posts folder. render Render files with renderer plugins. server Start the server. version Display version information. （六）参考资料https://blog.csdn.net/marvine/article/details/89816846 https://blog.csdn.net/zemprogram/article/details/104288872 https://blog.csdn.net/ye17186/article/details/111564883 https://gitee.com/W4j1e/hexo-douban-list2","link":"/2021/08/05/blog%E6%90%AD%E5%BB%BA%EF%BC%88%E8%AE%B0%E5%BD%95%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91%EF%BC%89/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2021/08/05/hello-world/"},{"title":"http和https的那些七七八八","text":"搭博客的这段时间，发现有些博客地址前面有个不安全的标志，而大佬们的博客前面都是一个锁。后来百度的才知道，原来二者所用的协议不一样： 不安全的标志是因为用的是Http协议，访问的是80端口，传输的数据如果不自己进行加密，传输的是明文 大佬们用的是Https协议，访问的是443端口，传输的数据进行了加密，安全性更好 Http协议与Https协议Http协议超文本传输协议（英文：HyperText Transfer Protocol，缩写：HTTP）是一种用于分布式、协作式和超媒体信息系统的应用层协议。HTTP是万维网的数据通信的基础，现在我们的网页浏览器，各种服务的接口，还有一些流应用都是基于Http协议的，在这里我就不赘述了，详情可以参考这篇博客，里面已经介绍的十分清楚了。 Https协议因为https协议涉及一些密码学的知识，先扫个盲 数据的加密与解密对称加密——服务器和客户端都有相同的密钥 对称加密：对称加密又叫做私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据。对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密，但是安全性低，一旦私钥泄露，数据就有被盗取的风险。 其加密过程如下：明文 + 加密算法 + 私钥 =&gt; 密文解密过程如下： 密文 + 解密算法 + 私钥 =&gt; 明文 非对称加密——顾名思义服务器和客户端拥有的密钥不对等 非对称加密：非对称加密也叫做公钥加密。非对称加密与对称加密相比，其安全性更好。对称加密的通信双方使用相同的密钥，如果一方的密钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对密钥，即公钥和私钥，且二者成对出现。私钥被自己保存，不能对外泄露。公钥指的是公共的密钥，任何人都可以获得该密钥。用公钥或私钥中的任何一个进行加密，用另一个进行解密。 被公钥加密过的密文只能被私钥解密，过程如下： 明文 + 加密算法 + 公钥 =&gt; 密文， 密文 + 解密算法 + 私钥 =&gt; 明文 被私钥加密过的密文只能被公钥解密，过程如下： 明文 + 加密算法 + 私钥 =&gt; 密文， 密文 + 解密算法 + 公钥 =&gt; 明文 由于加密和解密使用了两个不同的密钥，这就是非对称加密“非对称”的原因。非对称加密的缺点是加密和解密花费时间长、速度慢，只适合对少量数据进行加密。 Https协议传输原理HTTPS协议 = HTTP协议 + SSL/TLS协议，在HTTPS数据传输的过程中，需要用SSL/TLS对数据进行加密和解密，需要用HTTP对加密后的数据进行传输。https协议的基础是http协议，而且在一次https请求中，包含了两次http请求。 为了安全和灵活性，https同时使用了对称加密和非对称加密，用非对称加密传输密钥，用对称加密传输数据，这样一来，既可以防止他人拿到密钥，又减少了加密和解密花费的时间。下图展示了一次Https请求的流程： 一共分为8步，产生了两次http请求，期间有三个密钥客户端产生的随机密钥，服务器公钥，服务器私钥： client对server发起请求；第一次http请求 server端获取自己的公钥； server端将自己的公钥发给client端； client检验该公钥是否有效，无效则抛安全异常，有效则创建随机密钥，并用公钥加密随机密钥； client用随机密钥加密传输的请求，并将请求和用公钥加密后的随机密钥一起发给server；第二次http请求 server用自己的私钥解密随机密钥，得到随机密钥后，解密请求。 server对请求做出响应，将响应用随机密钥加密后，传给client端。 client端用随机密钥，解密出响应，并在浏览器上展示。 至此，一次https请求执行完毕。从中我们可以看到，私钥一直由服务器保存，我们传输的是公钥和客户端产生的随机密钥，所以只要私钥不被泄露，监听者是无法解密我们的请求与响应的。","link":"/2021/08/07/http%E5%92%8Chttps%E7%9A%84%E9%82%A3%E4%BA%9B%E4%B8%83%E4%B8%83%E5%85%AB%E5%85%AB/"},{"title":"为什么redis这么快","text":"最近在看一些关于redis的知识点，以前只知道它是一个非关系型数据库，适合用来做缓存，并且查询速度很快，但是它为什么这么快呢？ 1.redis是单线程的Redis的数据结构并不全是简单的Key-Value，还有list，hash等复杂的结构，比如在很长的列表后面添加一个元素，在hash当中添加或者删除一个对象的时候，这些操作可能就需要加非常多的锁，导致的结果是同步开销大大增加。而单线程，就不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗。 不过这里又引申了一个问题，理论上来说多线程能更好的提高程序的运行效率，那为什么redis单线程还这么快呢？ 因为Redis是基于内存的操作，CPU不是Redis的瓶颈，Redis的瓶颈最有可能是机器内存的大小或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈。 并且redis是将所有的数据放在内存中的，所以说使用单线程去操作效率就是最高的，多线程（CPU上下文会切换：耗时的操作！），对于内存系统来说，如果没有上下文切换效率就是最高的，多次读写都是在一个CPU上的，在内存存储数据情况下，单线程就是最佳的方案。 2.使用IO多路复用，非阻塞IO2.1为什么要使用I/O多路复用技术当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，就会阻塞在 accept() 函数，这导致其他客户端无法和 Redis 建立连接。 类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。这就导致 Redis 整个线程阻塞，无法处理。 2.2 什么是IO多路复用技术Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流。简单来说，在 Redis 只运行单线程的情况下，该机制允许内核中,内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。下图是IO多路复用的一个大致的模型图。","link":"/2021/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88redis%E8%BF%99%E4%B9%88%E5%BF%AB/"},{"title":"域名为什么可以以 . 结尾","text":"奇怪的知识增加了。 . 是根域名。访问所有域名理论上都是由根域名开始解析的。 比如访问 http://www.cctv.com 这个网址，计算机先知道这个网址对应的ip才能访问。所以要做一次解析，也就是找到 http://www.cctv.com 对应的IP，这个过程叫“DNS解析”. 这个过程怎么进行呢?分 4 步, 计算机先询问 “.”根域名服务器, “管理com域名解析服务器在哪里?” 得到”com域名解析服务器”的地址，再去询问”管理cctv的域名解析服务器在哪里?” 得到”cctv域名解析服务器”的地址，再去询问”www对应的服务器在哪里?” http://www.cctv.com 的地址 GET! 于是我们发现，所有的网址的解析都需要先去访问这个根域名服务器，为了优化输入增加效率，许多浏览器就省略掉它了，但是在DNS协议里面，还是会默默地把这个“.”加上的。","link":"/2021/08/07/%E5%9F%9F%E5%90%8D%E4%B8%BA%E4%BB%80%E4%B9%88%E5%8F%AF%E4%BB%A5%E4%BB%A5%20.%20%E7%BB%93%E5%B0%BE/"},{"title":"如何修复失败的Git提交","text":"在使用 Git 的时候，大家都碰到过忘记添加文件或是忘记写注释等等糟心的情况。幸运的是，Git 中有一些命令可以帮助处理这些常见的情况，下面列出常见的解决方法。 1.修改提交信息在提交消息的时候你发现了提交内容错误。这个是可以修改的： git commit --amend -m &quot;new message&quot; 2.添加文件到最后一次提交更改已经提交，但又忘记添加文件了。没问题，我们仍然可以将文件添加到这次提交中： git add &lt;file_name&gt; git commit --amend HEAD~1 3.撤消提交如果要撤消最近一次提交但保留更改，可执行以下操作： git reset --soft HEAD~1 如果要撤消提交和更改，可执行以下操作：注意，确定是要丢弃更改。 git reset --hard HEAD~1 还有一种情况是，如果要撤消所有的本地更改，则可以重置为分支的原始版本： git reset --hard origin/&lt;branch_name&gt; 如果要撤消提交而不修改现有历史记录，则可以使用 git revert，此命令通过创建新的提交来撤消提交。 git revert HEAD 如果你刚解决了冲突，完成了合并，并且推送到了原始版本。撤消已经推送到远程分支的合并提交的安全方法是使用 git revert 命令：(其中commit_id 是要还原的合并提交 id。) git revert -m 1 &lt;commit_id&gt; 注意要点： 可以撤消任意数量的提交。例如：git reset HEAD~3（返回 HEAD 之前的 3 个提交)；git reset --hard &lt;commit_id&gt;（返回特定的提交）。 如果尚未推送提交，并且你不想引入糟糕的提交到远程分支，可以使用 git reset。 使用 git revert 还原已经推送到远程分支的合并提交。 使用 git log 查看提交历史。","link":"/2021/08/08/%E5%A6%82%E4%BD%95%E4%BF%AE%E5%A4%8D%E5%A4%B1%E8%B4%A5%E7%9A%84Git%E6%8F%90%E4%BA%A4/"},{"title":"如何嵌入B站视频","text":"B 站的网页版已经提供了内嵌的 iframe 代码，我们只需要一键复制后就可以直接使用。 原版链接&lt;iframe src=&quot;//player.bilibili.com/player.html?aid=60731116&amp;bvid=BV1qt411j7fV&amp;cid=106015992&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt; &lt;/iframe&gt; 自适应版这样原版链接一般来说是够用了，但是它也有问题，我们能不能搞一种更通用的引用方式呢？ &lt;div style=&quot;position: relative; padding: 30% 45%;&quot;&gt; &lt;iframe style=&quot;position: absolute; width: 100%; height: 100%; left: 0; top: 0;&quot; src=&quot;//player.bilibili.com/player.html?aid=60731116&amp;bvid=BV1qt411j7fV&amp;cid=106015992&amp;page=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt; &lt;/div&gt; 参数说明： key 说明 aid 之前 B 站使用的 AV 号 bvid 目前的 BV 号 page 第几个视频, 起始下标为 1 (默认值也是为 1)就是 B 站视频, 选集里的, 第几个视频 as_wide 是否宽屏 【1: 宽屏, 0: 小屏】 high_quality 是否高清 【1: 高清(最高1080p) / 0: 最低视频质量(默认)】 danmaku 是否开启弹幕 【1: 开启(默认), 0: 关闭】","link":"/2021/08/07/%E5%A6%82%E4%BD%95%E5%B5%8C%E5%85%A5B%E7%AB%99%E8%A7%86%E9%A2%91/"},{"title":"常用的一些git操作命令","text":"远程克隆git clone XXXX.git 克隆远程指定分支git clone -b 分支名 XXXX.git 创建本地分支git branch 分支名 删除本地分支git branch -d 分支名 查看远程分支git branch -a 删除远程分支git branch -r -d origin/jinsong git push origin --delete 分支名 切换到分支git checkout 分支名 查看所在分支git branch -a 查看所有修改了还没有add的文件git diff 查看单个修改了还没有add的文件git diff 文件名 add所有文件git add -A add某个文件git add 文件全名 commit操作修改了文件必须先add才能commit git commit -m \"提交的描述信息\" 拉取远程分支到本地push前最好先用pull更新本地代码 git pull origin 分支名：分支名 （前一个是远程分支名，后一个是本地分支名） git pull origin 分支名（远程和本地分支同名） 推送本地分支到远程必须本地已经切换到“分支名” git push origin 分支名：分支名 （前一个是本地分支名，后一个是会在远程生成的分支名，通常都用同一个名字） git push origin 分支名 （本地和远程分支同名） 远程已有“分支名”并且已经关联本地“分支名”且本地已经切换到“分支名”git push 远程已有“分支名”但未关联本地“分支名”且本地已经切换到“分支名”git push -u origin/分支名 查看远程仓库信息git remote -v/分支名 本地添加新的远程仓库，远程仓库是空的git remote add 给远程仓库在本地起个名字 XXXX.git 推送本地分支到对应的远程仓库git push 远程仓库名字 分支名 关联本地和远程分支git branch --set-upstream-to=origin/远程分支名 本地分支名 查看版本号，回滚到指定版本，推送到远程git log git reset --hard 版本号 git push -f origin 分支名","link":"/2021/08/06/%E5%B8%B8%E7%94%A8%E7%9A%84git%E6%93%8D%E4%BD%9C/"},{"title":"正则表达式笔记","text":"正则过于重要（最近越来越多用到：Java的split函数、js、nginx的配置、Linux），但是我基本8会写，所以一边学一边记录下。 工具/网站安利 RegExp Tester：一个用于测试的chrome扩展，体积小且方便。 regexone：交互式学习和练习正则表达式的网站。 基础语法(PS:因为我就看会了这点，有不对的还请各位大佬指出，也可能手抖敲错了) 元字符 \\b：代表着单词的开头或结尾，也就是单词的分界处，它只匹配一个位置。 \\w：匹配字母或数字或下划线或汉字。 \\d：匹配数字，可以代替0到9之间的任何数字。 . ：匹配任何单个字符（字母，数字，空格，所有内容），实际上会覆盖句号字符的匹配，因此，为了专门匹配句号，使用斜杠\\来使句号转义。 \\s：匹配任意的空白符。 ^：匹配字符串的开始。 $：匹配字符串的结束。 ()：小括号来指定子表达式(也叫做分组)，然后可以对这个表达式指定各项操作。 转义查找元字符本身需要\\转义，例： regtest\\.py 匹配 regtest.py。 C:\\\\Windows 匹配 C:\\Windows。 反义 \\B：匹配不是单词开头或结束的位置。 \\W：匹配任意不是字母，数字，下划线，汉字的字符。 \\D：匹配任意非数字的字符。 \\S：匹配任意不是空白符的字符。 [\\^x]：匹配除了x以外的任意字符。 [\\^aeiou]：匹配除了aeiou这几个字母以外的任意字符。 例： \\S+ ：匹配不包含空白符的字符串。 &lt;a[^&gt;]+&gt; ：匹配用尖括号括起来的以a开头的字符串。 重复 * ：重复零次或更多次D + ：重复一次或更多次 ? ：重复零次或一次 {n}：重复n次 {n,}：重复n次或更多次 {n,m}：重复n到m次 例： Windows\\d+ ：匹配Windows后面跟1个或更多数字。 \\^\\w+ ：匹配 一行的第一个单词（或整个字符串的第一个单词）。 字符范围[]表示法中： -：表示字符范围。 ^ ：表示不要某几个字符。 例： [0-6] ：仅会匹配从零到六个的任何一位数字字符。 [^ np] ：将仅匹配任何单个字符，但字母n至p除外。 后向引用、分组、捕获默认情况下，每个分组会自动拥有一个组号，规则 是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。 捕获 (exp) ：匹配exp,并捕获文本到自动命名的组里。 (?exp) ：匹配exp,并捕获文本到名称为name的组里，也可以写成 (?’name’exp)。 (?:exp) ：匹配exp,不捕获匹配的文本，也不给此分组分配组号。（PS：不会改变正则表达式的处理方式，只是这样的组匹配的内容 不会像前两种那样 被捕获到某个组里面，也不会拥有组号。 零宽断言 (?=exp) ：匹配exp前面的位置 (?&lt;=exp) ：匹配exp后面的位置 (?!exp) ：匹配后面跟的不是exp的位置 (?&lt;!exp) ：匹配前面不是exp的位置 注释 (? #comment) ：这种类型的分组不对正则表达式的处理产生任何影响，用于提 供注释让人阅读 懒惰匹配匹配尽可能少的字符 *? ：重复任意次，但尽可能少重复 +? ：重复1次或更多次，但尽可能少重复 ??：重复0次或1次，但尽可能少重复 {n,m}?：重复n到m次，但尽可能少重复 {n,}?：重复n次以上，但尽可能少重复 常用的部分正则表达式整数或者小数：^[0-9]+\\.{0,1}[0-9]{0,2}$。 只能输入数字：^[0-9]*$。 只能输入n位的数字：^\\d{n}$。 只能输入至少n位的数字：^\\d{n,}$。 只能输入m到n位的数字：^\\d{m,n}$。 只能输入零和非零开头的数字：^(0|[1-9][0-9]*)$。 只能输入有两位小数的正实数：^[0-9]+(.[0-9]{2})?$。 只能输入有1到3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$。 只能输入非零的正整数：^\\+?[1-9][0-9]*$。 只能输入非零的负整数：^\\-[1-9][]0-9″*$。 只能输入长度为3的字符：^.{3}$。 只能输入由26个英文字母组成的字符串：^[A-Za-z]+$。 只能输入由26个大写英文字母组成的字符串：^[A-Z]+$。 只能输入由26个小写英文字母组成的字符串：^[a-z]+$。 只能输入由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$。 只能输入由数字、26个英文字母或者下划线组成的字符串：^\\w+$。 验证用户密码：^[a-zA-Z]\\w{5,17}$。 正确格式为：以字母开头，长度在6~18之间，只能包含字符、数字和下划线。验证是否含有^%&amp;’,;=?$\\等字符：[^%&amp;',;=?$\\x22]+。 只能输入汉字：^[\\u4e00-\\u9fa5]{0,}$。 验证Email地址：^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$。 验证InternetURL：^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$。 123验证电话号码：^(\\(\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$。正确格式为：XXX-XXXXXXX、XXXX-XXXXXXXX、XXX-XXXXXXX、XXX-XXXXXXXX、XXXXXXX和XXXXXXXX。 验证身份证号（15位或18位数字）：^\\d{15}|\\d{18}$。 12345验证一年的12个月：^(0?[1-9]|1[0-2])$。正确格式为：”01″～”09″和”1″～”12″。验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$正确格式为；”01″～”09″和”1″～”31″。 匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]。 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff]。 应用：计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）String.prototype.len=function(){return this.replace(/[^\\x00-\\xff]/g,”aa”).length;} 匹配空行的正则表达式：\\n[\\s| ]*\\r 匹配html标签的正则表达式：&lt;(.*)&gt;(.*)&lt;\\/(.*)&gt;|&lt;(.*)\\/&gt; 12345678910111213匹配首尾空格的正则表达式：(^\\s*)|(\\s*$)应用：javascript中没有像vbscript那样的trim函数，我们就可以利用这个表达式来实现，如下：String.prototype.trim = function(){return this.replace(/(^\\s*)|(\\s*$)/g, “”);}利用正则表达式分解和转换IP地址：下面是利用正则表达式匹配IP地址，并将IP地址转换成对应数值的Javascript程序：function IP2V(ip){re=/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)/g //匹配IP地址的正则表达式if(re.test(ip)){return RegExp.$1*Math.pow(255,3))+RegExp.$2*Math.pow(255,2))+RegExp.$3*255+RegExp.$4*1}else{throw new Error(“Not a valid IP address!”)}}//上面的程序直接用split函数来分解var ip=”10.100.20.168″ip=ip.split(“.”)alert(“IP值是：”+(ip[0]*255*255*255+ip[1]*255*255+ip[2]*255+ip[3]*1)) 匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 匹配网址URL的正则表达式：http://([\\w-]+\\.)+[\\w-]+(/[\\w- ./?%&amp;=]*)? 利用正则表达式限制网页表单里的文本框输入内容：用正则表达式限制只能输入中文： onkeyup=”value=value.replace(/[^\\u4E00-\\u9FA5]/g,”)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\u4E00-\\u9FA5]/g,”))” 用正则表达式限制只能输入全角字符： onkeyup=”value=value.replace(/[^\\uFF00-\\uFFFF]/g,”)” onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\uFF00-\\uFFFF]/g,”))” 用正则表达式限制只能输入数字： onkeyup=”value=value.replace(/[^\\d]/g,”) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\d]/g,”))” 用正则表达式限制只能输入数字和英文： onkeyup=”value=value.replace(/[\\W]/g,”) “onbeforepaste=”clipboardData.setData(‘text’,clipboardData.getData(‘text’).replace(/[^\\d]/g,”))” 123匹配中文字符的正则表达式： [\\u4e00-\\u9fa5]匹配双字节字符(包括汉字在内)： [^\\x00-\\xff]用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1）匹配空白行的正则表达式：\\n\\s*\\r 可以用来删除空白行匹配HTML标记的正则表达式（仅对部分简单情况适用）：&lt;(\\S*?)[^&gt;]*&gt;.*?|&lt;.*? /&gt; 匹配首尾空白字符的正则表达式：^\\s*|\\s*$ 可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式匹配Email地址的正则表达式：\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)* 表单验证时很实用匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]* 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 表单验证时很实用匹配国内电话号码：\\d{3}-\\d{8}|\\d{4}-\\d{7} 匹配形式如 0511-4405222 或 021-87888822 匹配腾讯QQ号：[1-9][0-9]{4,} 从10000开始匹配中国邮政编码(中国邮政编码为6位数字)：[1-9]\\d{5}(?!\\d) 匹配ip地址：((2[0-4]\\d|25[0-5]|[01]?\\d\\d?)\\.){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?) 匹配正整数: ^-[1-9]\\d*$ 匹配负整数: ^-?[1-9]\\d*$ 匹配整数: ^[1-9]\\d*|0$ 匹配非负整数（正整数 + 0）: ^-[1-9]\\d*|0$ 匹配非正整数（负整数 + 0）: ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*$ 匹配正浮点数: ^-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*)$ 匹配负浮点数: ^-?([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0)$ 匹配浮点数: ^[1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*|0?\\.0+|0$ 匹配非负浮点数（正浮点数 + 0）: ^(-([1-9]\\d*\\.\\d*|0\\.\\d*[1-9]\\d*))|0?\\.0+|0$ 匹配非正浮点数（负浮点数 + 0）: ^[A-Za-z]+$ (处理大量数据时有用，具体应用时注意修正匹配特定字符串) 匹配由26个英文字母组成的字符串: ^[A-Z]+$ 匹配由26个英文字母的大写组成的字符串: ^[a-z]+$ 匹配由26个英文字母的小写组成的字符串: ^[A-Za-z0-9]+$ Email : /^\\w+([-+.]\\w+)*@\\w+([-.]\\\\w+)*\\.\\w+([-.]\\w+)*$/ isEmail1 : /^\\w+([\\.\\-]\\w+)*\\@\\w+([\\.\\-]\\w+)*\\.\\w+$/; isEmail2 : /^.*@[^_]*$/; Phone : /^((\\(\\d{3}\\))|(\\d{3}\\-))?(\\(0\\d{2,3}\\)|0\\d{2,3}-)?[1-9]\\d{6,7}$/ Mobile : /^((\\(\\d{3}\\))|(\\d{3}\\-))?13\\d{9}$/","link":"/2021/08/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"},{"title":"网站流量小知识","text":"名称 全称 作用 PV Page view 页面浏览量，用户每打开 1 个网站页面，记录 1 个 PV；用户多次打开同一页面，PV 值累计多次。 UV Unique visitor 网站独立访客；1 天内相同访客多次访问网站，只计算为 1 个独立访客 IP Internet Protocol 1 天之内（00:00 ~ 24:00），访问网站的不重复的 IP 数 VV Viedo view 一个统计周期内，视频被打开的次数","link":"/2021/08/06/%E7%BD%91%E7%AB%99%E6%B5%81%E9%87%8F%E5%B0%8F%E7%9F%A5%E8%AF%86/"},{"title":"设置[阅读全文]","text":"在首页显示一篇文章的部分内容，并提供一个链接跳转到全文页面是一个常见的需求。 NexT 提供三种方式来控制文章在首页的显示方式。 也就是说，在首页显示文章的摘录并显示 阅读全文 按钮，可以通过以下方法： 1、在文章中使用&lt;!– more –&gt; 手动进行截断，Hexo 提供的方式 推荐(也可使用&lt;escape&gt;&lt;!– more –&gt;&lt;/escape&gt;) 2、在文章的 front-matter 中添加 description，并提供文章摘录 3、自动形成摘要，在主题配置文件中添加： auto_excerpt: enable: true length: 150 默认截取的长度为 150 字符，可以根据需要自行设定 建议使用&lt;!– more –&gt;（即第一种方式），除了可以精确控制需要显示的摘录内容以外， 这种方式也可以让 Hexo 中的插件更好的识别。","link":"/2021/08/06/%E8%AE%BE%E7%BD%AE-%E9%98%85%E8%AF%BB%E5%85%A8%E6%96%87/"},{"title":"输入网址之后的种种","text":"在学习了部分网络知识后，我们可以大致的想象到在键入网址后，到网页显示出对应内容，其间发生了什么 接下来以简单的网络拓扑模型作为例子，探究一个数据包在网络中发生的种种。 HTTP浏览器做的第一步工作是解析 URL 首先浏览器做的第一步工作就是要对 URL 进行解析，从而生发送给 Web 服务器的请求信息。 让我们看看一条长长的 URL 里的各个元素的代表什么，见下图： 所以图中的长长的 URL 实际上是请求服务器里的文件资源。 要是上图中的蓝色部分 URL 元素都省略了，哪应该是请求哪个文件呢？ 当没有路径名时，就代表访问根目录下事先设置的默认文件，也就是 /index.html 或者 /default.html 这些文件，这样就不会发生混乱了。 生产 HTTP 请求信息对 URL 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。 真实地址查询 —— DNS通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 Web 服务器。 但在发送之前，还有一项工作需要完成，那就是查询服务器域名对于的 IP 地址，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。 比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。 所以，有一种服务器就专门保存了 Web 服务器域名与 IP 的对应关系，它就是 DNS 服务器。 域名的层级关系DNS 中的域名都是用句点来分隔的，比如 www.server.com，这里的句点代表了不同层次之间的界限。 在域名中，越靠右的位置表示其层级越高。 毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。 根域是在最顶层，它的下一层就是 com 顶级域，再下面是 server.com。 所以域名的层级关系类似一个树状结构： 根 DNS 服务器 顶级域 DNS 服务器（com） 权威 DNS 服务器（server.com） 根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中。 这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。 因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。 域名解析的工作流程 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。” 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？” 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。 至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。 协议栈通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的协议栈。 协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。 应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，它们两会接受应用层的委托执行收发数据的操作。 协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据刽被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。 此外 IP 中还包括 ICMP 协议和 ARP 协议。 ICMP 用于告知网络包传送过程中产生的错误以及各种控制信息。 ARP 用于根据 IP 地址查询相应的以太网 MAC 地址。 IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。 可靠传输 —— TCPHTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。 TCP 包头格式我们先看看 TCP 报文头部的格式： 首先，源端口号和目标端口号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。 接下来有包的序号，这个是为了解决包乱序的问题。 还有应该有的是确认号，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决不丢包的问题。 接下来还有一些状态位。例如 SYN 是发起一个连接，ACK 是回复，RST 是重新连接，FIN 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。 还有一个重要的就是窗口大小。TCP 要做流量控制，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。 除了做流量控制以外，TCP还会做拥塞控制，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。 TCP 传输数据之前，要先三次握手建立连接在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为三次握手。 这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。 一开始，客户端和服务端都处于 CLOSED 状态。先是服务端主动监听某个端口，处于 LISTEN 状态。 然后客户端主动发起连接 SYN，之后处于 SYN-SENT 状态。 服务端收到发起的连接，返回 SYN，并且 ACK 客户端的 SYN，之后处于 SYN-RCVD 状态。 客户端收到服务端发送的 SYN 和 ACK 之后，发送 ACK 的 ACK，之后处于 ESTABLISHED 状态，因为它一发一收成功了。 服务端收到 ACK 的 ACK 之后，处于 ESTABLISHED 状态，因为它也一发一收了。 所以三次握手目的是保证双方都有发送和接收的能力。 如何查看 TCP 的连接状态？TCP 的连接状态查看，在 Linux 可以通过 netstat -napt 命令查看。 TCP 分割数据如果 HTTP 请求消息比较长，超过了 MSS 的长度，这时 TCP 就需要把 HTTP 的数据拆解一块块的数据发送，而不是一次性发送所有数据。 MTU：一个网络包的最大长度，以太网中一般为 1500 字节。 MSS：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。 数据会被以 MSS 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。 TCP 报文生成TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 80， HTTPS 默认端口号是 443）。 在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。 至此，网络包的报文如下图: 远程定位 —— IPTCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成网络包发送给通信对象。 IP 包头格式我们先看看 IP 报文头部的格式： 在 IP 协议里面需要有源地址 IP 和 目标地址 IP： 源地址IP，即是客户端输出的 IP 地址； 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。 因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的协议号，要填写为 06（十六进制），表示协议为 TCP。 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。 这个时候就需要根据路由表规则，来判断哪一个网卡作为源地址 IP。 在 Linux 操作系统，我们可以使用 route -n 命令查看当前系统的路由表。 举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 192.168.10.200。 首先先和第一条条目的子网掩码（Genmask）进行 与运算，得到结果为 192.168.10.0，但是第一个条目的 Destination 是 192.168.3.0，两者不一致所以匹配失败。 再与第二条目的子网掩码进行 与运算，得到的结果为 192.168.10.0，与第二条目的 Destination 192.168.10.0 匹配成功，所以将使用 eth1 网卡的 IP 地址作为 IP 包头的源地址。 那么假设 Web 服务器的目标地址是 10.100.20.100，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。 第三条目比较特殊，它目标地址和子网掩码都是 0.0.0.0，这表示默认网关，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，Gateway 即是路由器的 IP 地址。 IP 报文生成至此，网络包的报文如下图: 两点传输 —— MAC生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 MAC 头部。 MAC 包头格式MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。 在 MAC 包头里需要发送方 MAC 地址和接收方目标 MAC 地址，用于两点之间的传输。 一般在 TCP/IP 通信里，MAC 包头的协议类型只使用： 0800 ：IP 协议 0806 ：ARP 协议 MAC 发送方和接收方如何确认?发送方的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。 接收方的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。 所以先得搞清楚应该把包发给谁，这个只要查一下路由表就知道了。在路由表中找到相匹配的条目，然后把包发给 Gateway 列中的 IP 地址就可以了。 既然知道要发给谁，按如何获取对方的 MAC 地址呢？不知道对方 MAC 地址？不知道就喊呗。 此时就需要 ARP 协议帮我们找到路由器的 MAC 地址。 ARP 协议会在以太网中以广播的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。 然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。 如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。 每次都要广播获取，这不是很麻烦吗？放心，在后续操作系统会把本次查询结果放到一块叫做 ARP 缓存的内存空间留着以后用，不过缓存的时间就几分钟。 也就是说，在发包时： 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。 查看 ARP 缓存内容在 Linux 系统中，我们可以使用 arp -a 命令来查看 ARP 缓存的内容。 MAC 报文生成至此，网络包的报文如下图: 出口 —— 网卡IP 生成的网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将数字信息转换为电信号，才能在网线上传输，也就是说，这才是真正的数据发送过程。 负责执行这一操作的是网卡，要控制网卡还需要靠网卡驱动程序。 网卡驱动从 IP 模块获取到包之后，会将其复制到网卡内的缓存区中，接着会其开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列。 起始帧分界符是一个用来表示包起始位置的标记 末尾的 FCS（帧校验序列）用来检查包传输过程是否有损坏 最后网卡会将包转为电信号，通过网线发送出去。 送别者 —— 交换机下面来看一下包是如何通过交换机的。交换机的设计是将网络包原样转发到目的地。交换机工作在 MAC 层，也称为二层网络设备。 交换机的包接收操作首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。 然后通过包末尾的 FCS 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。 计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，交换机的端口不具有 MAC 地址。 将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。 交换机的 MAC 地址表主要包含两个信息： 一个是设备的 MAC 地址， 另一个是该设备连接在交换机的哪个端口上。 举个例子，如果收到的包的接收方 MAC 地址为 00-02-B3-1C-9C-F9，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 3 号端口上，然后就可以通过交换电路将包发送到相应的端口了。 所以，交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口。 当 MAC 地址表找不到指定的 MAC 地址会怎么样？地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。 这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。 这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后只有相应的接收者才接收包，而其他设备则会忽略这个包。 有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？” 其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。 局域网中每秒可以传输上千个包，多出一两个包并无大碍。 此外，如果接收方 MAC 地址是一个广播地址，那么交换机会将包发送到除源端口之外的所有端口。 以下两个属于广播地址： MAC 地址中的 FF:FF:FF:FF:FF:FF IP 地址中的 255.255.255.255 出境大门 —— 路由器 路由器与交换机的区别网络包经过交换机之后，现在到达了路由器，并在此被转发到下一个路由器或目标设备。 这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。 不过在具体的操作过程上，路由器和交换机是有区别的。 因为路由器是基于 IP 设计的，俗称三层网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址； 而交换机是基于以太网设计的，俗称二层网络设备，交换机的端口不具有 MAC 地址。 路由器基本原理路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。 当转发包时，首先路由器端口会接收发给自己的以太网包，然后路由表查询转发目标，再由相应的端口作为发送方将以太网包发送出去。 路由器的包接收操作首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 FCS 进行错误校验。 如果没问题则检查 MAC 头部中的接收方 MAC 地址，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。 总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。 查询路由表确定输出端口完成包接收操作之后，路由器就会去掉包开头的 MAC 头部。 MAC 头部的作用就是将包送达路由器，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会被丢弃。 接下来，路由器会根据 MAC 头部后方的 IP 头部中的内容进行包的转发操作。 转发操作分为几个阶段，首先是查询路由表判断转发目标。 具体的工作流程根据上图，举个例子。 假设地址为 10.10.1.101 的计算机要向地址为 192.168.1.100 的服务器发送一个包，这个包先到达图中的路由器。 判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。 路由匹配和前面讲的一样，每个条目的子网掩码和 192.168.1.100 IP 做 &amp; 与运算后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。 如第二条目的子网掩码 255.255.255.0 与 192.168.1.100 IP 做 &amp; 与运算后，得到结果是 192.168.1.0 ，这与第二条目的目标地址 192.168.1.0 匹配，该第二条目记录就会被作为转发目标。 实在找不到匹配路由时，就会选择默认路由，路由表中子网掩码为 0.0.0.0 的记录表示「默认路由」。 路由器的发送操作接下来就会进入包的发送操作。 首先，我们需要根据路由表的网关列判断对方的地址。 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，还未抵达终点，还需继续需要路由器转发。 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明已抵达终点。 知道对方的 IP 地址之后，接下来需要通过 ARP 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。 路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。 接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 0080 （十六进制）表示 IP 协议。 网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。 发送出去的网络包会通过交换机到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。 接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。 不知你发现了没有，在网络包传输的过程中，源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址，因为需要 MAC 地址在以太网内进行两个设备之间的包传输。 互相扒皮 —— 服务器 与 客户端数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？ 服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？ 数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。 接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。 于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。 于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。 服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。 HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。 穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。 最后跳到了客户端的城门把手的路由器，路由器扒开 IP 头部发现是要找城内的人，于是把包发给了城内的交换机，再由交换机转发到客户端。 客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！ 于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！ 最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。","link":"/2021/08/13/%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E7%A7%8D%E7%A7%8D/"},{"title":"MySQL比较运算符","text":"最近在看《MySQL必知必会》，其中对于mysql中运算符的运用有较多讲解，现做部分笔记 MySQL 运算符 运算符 描述 备注 &gt; / &gt;= 大于 / 大于等于 &lt; / &lt;= 小于 / 小于等于 &lt;&gt; / != 不等于 两者都是不等于，和 &lt;=&gt; 运算符有区别 &lt;=&gt; NULL-safe 等于运算符 在某些场景下特别有用 = 等于 MySQL 比较在 MySQL 中，NULL 和 NULL 是没法做比较的，也就是 NULL = NULL 的返回值是 NULL。 1234567891011121314MariaDB [mybatis]&gt; SELECT NULL = NULL;+-------------+| NULL = NULL |+-------------+| NULL |+-------------+MariaDB [mybatis]&gt; SELECT NULL != NULL;+--------------+| NULL != NULL |+--------------+| NULL |+--------------+ &gt; &gt;= &lt; &lt;= = != &lt;&gt; 都是如上同理。要判断是不是 NULL，可以使用 IS NULL / IS NOT NULL 进行判断。 1234567891011121314MariaDB [mybatis]&gt; SELECT NULL IS NULL;+--------------+| NULL IS NULL |+--------------+| 1 |+--------------+MariaDB [mybatis]&gt; SELECT NULL IS NOT NULL;+------------------+| NULL IS NOT NULL |+------------------+| 0 |+------------------+ 这样子的结果是对的，但是还存在一种情况，我们不知道要比较的值是不是 NULL，这时候就需要 &lt;=&gt;。 123456789101112131415161718192021222324252627282930MariaDB [mybatis]&gt; SELECT NULL &lt;=&gt; NULL;+---------------+| NULL &lt;=&gt; NULL |+---------------+| 1 |+---------------+MariaDB [mybatis]&gt; SELECT 1 &lt;=&gt; NULL;+------------+| 1 &lt;=&gt; NULL |+------------+| 0 |+------------+MariaDB [mybatis]&gt; SELECT !(1 &lt;=&gt; NULL);+---------------+| !(1 &lt;=&gt; NULL) |+---------------+| 1 |+---------------+MariaDB [mybatis]&gt; SELECT !(NULL &lt;=&gt; NULL);+------------------+| !(NULL &lt;=&gt; NULL) |+------------------+| 0 |+------------------+ 有时候需要在 WHERE 里面写 name = ${name} AND type = 1，你想要查询 name 这个字段为 NULL 的记录并且 type 等于 1，但是发现不管怎么查询都是 Empty set。 如果换成 name &lt;=&gt; ${name} AND type = 1 这样子 name 的值传入 NULL，也可以查询，也就是查询 name 为 NULL（相当于 name IS NULL） 并且 type 等于 1 的记录。 name 传入的值非 NULL，例如 AAA，也就会查询 name 等于 AAA 并且 type 等于 1 的记录。 当然了，你也可以在程序里面判断 name 是不是 NULL，如果是 NULL 的话使用 name IS NULL AND type = 1 进行查询。 不是 NULL，就使用 name = ${name} AND type =1 进行查询。","link":"/2021/10/08/MySQL%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6/"},{"title":"《MySQL必知必会》笔记1","text":"最近在看《MySQL必知必会》，现做部分笔记，这是第一章至第十章的内容 第一章 了解SQL数据库：保存有组织的数据的容器（通常是一个文件或一组文件） 表: 表名唯一，取决多个因素，如不同数据库的表可以同名 模式: 关于数据库和表的布局及特性的信息、 列: 表中的字段 行: 行(raw)和记录(record)很大程度可以等同，但行才是正确的术语 数据类型: 限制数据种类，帮助正确排序，磁盘优化方面的作用 主键（primary key）: 一列，其值可以唯一区分表中的行。 SQL （Structured Query Language）：结构化查询语言。 主键条件：1、每行都应有一个主键，所以其值不为null。 2、任意两行间的主键值不同。 主键通常是一列，但也可多列共同构成主键。 主键设置建议：1、不更新主键列中的值； 2、不重用主键列的值； 3、不在主键列中使用可能会更改的值。 SQL命令执行：1、命令在mysql&gt;之后输入； 2、命令用 ；或 \\g 结束，仅按Enter不执行命令； 3、输入 help 或 \\h 获取帮助； 4、输入 quit 或 exit 退出程序。 基本语句：12345678910111213141516171819202122232425myslq -u root -p;use Database;#SHOW相关SHOW databases;SHOW tables;SHOW columns FROM tables; -- 等于 describe &quot;tables&quot;;SHOW CREATE DATABASE db_name; 显示完整的建库语句SHOW CREATE TABLE tbl_name;SHOW [STORAGE] ENGINES#SELECT相关SELECT column_name1,column_name2 FROM table;SELECT *FROM tables;-- Distinct-- 不能部分使用DISTINCT，其应用于所有列而不是其前置列SELECT DISTINCT column_namw FROM table; -- Limit 从第零个开始后的5个 取的时候排列顺序是从零开始的。SELECT column_name FROM table_name LIMIT 5;-- 从第二个开始后的5个SELECT column_name FROM table_name LIMIT 2,5;-- OFFSET 限制两个，从第三为开始取SELECT column_name FROM table_name LIMIT 2 OFFSET 3; -- 使用全限定的表名 库：manxc 表：tagsSELECT tags.tid FROM manxc.tags; 排序检索数据关键字：ORDER BY 12SELECT column_name FROM table_name ORDER BY column_name; 默认升序，字母按A-Z排，数字从小到大； 注：排序中文时出现问题。解决方式： 1 修改数据库表字段： 对于包含中文的字段加上binary属性，使之作为二进制比较。 eg: 将name char(10) 改成 name char(10)binary 2 修改查询语句： 如果不想修改数据库中表字段属性的话，也可以在查询语句的order by部分使用 CONVERT函数。 eg: select * from pub_user_info u where u.sex='1' order by CONVERT(u.name USING GBK) asc; ps：数据库表结构一般在确定后就尽量不要去做改动，所以推荐使用第二种方法 升序（默认）：ASC降序：DESC 过滤数据关键字：WHERE（同时可与其它关键字组合） 123456789101112131415SELECT * FROM manxc.tags WHERE tags.tid BETWEEN 2 AND 9 ORDER BY tid DESC,tagname;操作符 说明= 等于&lt;&gt; 不等于!= 不等于&lt; 小于&lt;= 小于等于&gt; 大于&gt;= 大于等于BETWEEN 在指定的两个值之间此处可详见文章：MySQL比较运算符 eg: 12345678910mysql&gt; SELECT 2 BETWEEN 1 AND 3, 2 BETWEEN 3 and 1; -&gt; 1, 0 mysql&gt; SELECT 1 BETWEEN 2 AND 3; -&gt; 0 mysql&gt; SELECT 'b' BETWEEN 'a' AND 'c'; -&gt; 1 mysql&gt; SELECT 2 BETWEEN 2 AND '3'; -&gt; 1 mysql&gt; SELECT 2 BETWEEN 2 AND 'x-3'; -&gt; 0 WHERE 匹配字符加‘’；且其在执行匹配时默认不区分大小写； 123456mysql&gt; SELECT uid,username,state FROM manxc.user WHERE username='FLY';+-----+----------+-------+| uid | username | state |+-----+----------+-------+| 3 | fly | 0 |+-----+----------+-------+ 空值检查：IS NULL (空值是无值和0和空格不同) 12345678mysql&gt; SELECT uid,username,state FROM user WHERE password IS NULL LIMIT 3;+-----+----------+-------+| uid | username | state |+-----+----------+-------+| 8 | dfdg | NULL || 9 | dgdg | NULL || 10 | gdg | NULL |+-----+----------+-------+ 数据过滤操作符（operator） :用来联结或改变where子句的关键字。 AND 操作符 1234567891011mysql&gt; SELECT uid,username,state FROM USER WHERE state IS NULL AND uid &lt;= 13;+-----+-----------+-------+| uid | username | state |+-----+-----------+-------+| 8 | dfdg | NULL || 9 | dgdg | NULL || 10 | gdg | NULL || 11 | dgdgh | NULL || 12 | dgklds | NULL || 13 | dgkljdlkg | NULL |+-----+-----------+-------+ OR操作符： 123456789101112131415161718192021222324mysql&gt; SELECT uid,username,state FROM USER WHERE state IS NULL OR uid &lt;= 13;+-----+--------------+-------+| uid | username | state |+-----+--------------+-------+| 4 | test1 | 0 || 3 | fly | 0 || 5 | test2 | 0 || 6 | test3 | 1 || 7 | 1 | 1 || 8 | dfdg | NULL || 9 | dgdg | NULL || 10 | gdg | NULL || 11 | dgdgh | NULL || 12 | dgklds | NULL || 13 | dgkljdlkg | NULL || 14 | fdjwe | NULL || 15 | gkdlkg | NULL || 16 | dgdlkjg | NULL || 17 | fdglkdjg | NULL || 18 | gkldssjgdsas | NULL || 19 | dgjkljg | NULL || 20 | djglkdg | NULL || 21 | kgdlksgj | NULL |+-----+--------------+-------+ 混合使用时的顺序：在有多个or和and同时使用时，优先处理and，可以使用()提高优先级。 1234567891011121314151617181920212223242526272829303132333435mysql&gt; SELECT uid,username,state FROM USER WHERE (state IS NULL OR state =1) AND uid &lt;=10;+-----+----------+-------+| uid | username | state |+-----+----------+-------+| 6 | test3 | 1 || 7 | 1 | 1 || 8 | dfdg | NULL || 9 | dgdg | NULL || 10 | gdg | NULL |+-----+----------+-------+5 rows in set (0.00 sec)mysql&gt; SELECT uid,username,state FROM USER WHERE state IS NULL OR state =1 AND uid &lt;=10;+-----+--------------+-------+| uid | username | state |+-----+--------------+-------+| 6 | test3 | 1 || 7 | 1 | 1 || 8 | dfdg | NULL || 9 | dgdg | NULL || 10 | gdg | NULL || 11 | dgdgh | NULL || 12 | dgklds | NULL || 13 | dgkljdlkg | NULL || 14 | fdjwe | NULL || 15 | gkdlkg | NULL || 16 | dgdlkjg | NULL || 17 | fdglkdjg | NULL || 18 | gkldssjgdsas | NULL || 19 | dgjkljg | NULL || 20 | djglkdg | NULL || 21 | kgdlksgj | NULL |+-----+--------------+-------+16 rows in set (0.00 sec) 建议：使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确的分组，不用过分依赖计算次序，使用括号没有坏处且能消除歧义。 IN 操作符：where子句使用in操作符 1234567891011mysql&gt; SELECT uid,username,state FROM user WHERE state IN (0,1);+-----+----------+-------+| uid | username | state |+-----+----------+-------+| 4 | test1 | 0 || 3 | fly | 0 || 5 | test2 | 0 || 6 | test3 | 1 || 7 | 1 | 1 |+-----+----------+-------+5 rows in set (0.00 sec) IN 和 OR 有类似作用，此句表示查询state是0或1的。 IN操作符的优点：1、使用IN时，计算次序更容易管理（操作符少了，没那么多or） 2、IN操作符的语法更清楚且直观； 3、IN一般比OR的执行更快； 4、IN的最大优点时可以包含其它SELECT语句，使得能更动态的建立WHERE子句。 NOT 操作符：where子句中，not用来否定之后跟的条件。 12345678910111213141516171819mysql&gt; select * from tags where tid NOT IN (1,2,3,4,5,6,7,8,9,10);+-----+---------+| tid | tagname |+-----+---------+| 11 | 猎奇 || 12 | 少女 || 13 | 魔法 || 14 | 历史 || 15 | 机战 || 16 | 神魔 || 17 | 运动 || 18 | 励志 || 19 | 音乐 || 20 | 推理 || 21 | 美食 || 22 | 催泪 || 23 | 职场 || 26 | 搞笑 |+-----+---------+ 注：MySQL支持使用NOT对IN，BETWEEN，EXISTS子句取反。 统配符过滤关键字：like 统配符匹配： 1、百分号（%）通配符：表示任何字符出现任意次数，（任意字数的任意字符） 注： A.由配置方式，搜索时可以区分大小写的； B.注意尾空格，尾空格会干扰匹配，可在其前后都家%,或者使用函数。 2、下划线（_）: 任意的单个字符； 注：统配符的搜索处理比之前操作符的效率更低使用时： A.不要过度使用，能用其他操作符的，尽量用。 B.除非有绝对必要，不要把通配符放在搜索模式的开始处，这样是最慢的。 C.注意统配符放的位置。 12SELECT prod_id,prod_name FROM productsWHERE prod_name LIKE '%ton anvil'; 正则表达式搜索关键字：REGEXP 其后跟正则表达式 LIKE与REGEXP的区别： LIKE匹配整个列，如果匹配的文本在列值中出现，LIKE不会找到它，相应行也不会返回（除非使用统配符），而REGEXP可以在列值中进行匹配： 123456789101112mysql&gt; SELECT uid,username,password,state FROM user WHERE username LIKE &quot;test&quot;;Empty set (0.00 sec)mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;test&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 |+-----+----------+----------+-------+3 rows in set (0.05 sec) 注：MYSQL中正则匹配不区分大小写，如需区分可使用BINARY关键字，如WHERE prod-name REGEXP BINARY 'JetPack' 进行or匹配 使用“|”1234567891011121314mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;1|lk&quot;;+-----+-----------+----------+-------+| uid | username | password | state |+-----+-----------+----------+-------+| 4 | test1 | 123 | 0 || 7 | 1 | 1 | 1 || 13 | dgkljdlkg | NULL | NULL || 15 | gkdlkg | NULL | NULL || 16 | dgdlkjg | NULL | NULL || 17 | fdglkdjg | NULL | NULL || 20 | djglkdg | NULL | NULL || 21 | kgdlksgj | NULL | NULL |+-----+-----------+----------+-------+8 rows in set (0.00 sec) 匹配字符：使用“[ ]”匹配，相当于另一种形式的or；匹配其中的任意字符 123456789101112131415161718192021222324252627282930313233343536373839404142mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;test&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 || 22 | test4 | NULL | NULL || 23 | test5 | NULL | NULL || 24 | test6 | NULL | NULL |+-----+----------+----------+-------+6 rows in set (0.00 sec)mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;test[123]&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 |+-----+----------+----------+-------+3 rows in set (0.00 sec)mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;[123]test&quot;;Empty set (0.00 sec)mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;[test]&quot;;+-----+--------------+----------+-------+| uid | username | password | state |+-----+--------------+----------+-------+| 4 | test1 | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 || 12 | dgklds | NULL | NULL || 14 | fdjwe | NULL | NULL || 18 | gkldssjgdsas | NULL | NULL || 21 | kgdlksgj | NULL | NULL || 22 | test4 | NULL | NULL || 23 | test5 | NULL | NULL || 24 | test6 | NULL | NULL |+-----+--------------+----------+-------+10 rows in set (0.00 sec) 加上“^”表非 123456789mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;test[^123]&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 22 | test4 | NULL | NULL || 23 | test5 | NULL | NULL || 24 | test6 | NULL | NULL |+-----+----------+----------+-------+3 rows in set (0.00 sec) 空格 12345678mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;1|2 test&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 7 | 1 | 1 | 1 |+-----+----------+----------+-------+2 rows in set (0.00 sec) 匹配范围:如[1-3],[a-z]; 123456789mysql&gt; SELECT uid,username,password,state FROM user WHERE username REGEXP &quot;test[1-3]&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 |+-----+----------+----------+-------+3 rows in set (0.00 sec) 匹配特殊字符： 使用 “\\\\特殊字符”，即转义 \\\\.能够匹配. \\\\f换页 \\\\n换行 \\\\r回车 \\\\t制表 \\\\纵向制表 注意： a)为了匹配 \\ 本身，需要使用 \\\\\\ b)在一般情况下正则表达式的转义加一个“\\”就可以了，在MySQL中需要加两个。 匹配字符类：[:alnum:]=[a-zA-Z0-9] [:alpha:]=[a-zA-Z] [:digit:]=[0-9] [:lower:]=[a-z] [:upper:]=[A-Z] [:xdigit:]=[a-fA-F0-9] 重复次数匹配将其加在之后：元字符 说明 * 0个或多个匹配 + 1个或多个匹配（等于{1，}） ？ 0个或1个匹配（等于{0，1}） {n} 指定数目匹配 {n,} 不少于指定数目匹配 {n,m} 匹配数目的范围 匹配任意三个连续数字： 问：把其[ [ ] ]是一种更好习惯？还是有什么区别 答：所以这里的区别是[[:digit:]],[:digit:]有的 1234567891011121314151617181920212223242526mysql&gt; SELECT uid,username,password,state FROM user WHERE password REGEXP &quot;[[:digit:]]{3}&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 3 | fly | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 || 8 | dfdg | d124 | NULL || 9 | dgdg | 123r | NULL |+-----+----------+----------+-------+6 rows in set (0.00 sec)mysql&gt; SELECT uid,username,password,state FROM user WHERE password REGEXP &quot;[:digit:]{3}&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 3 | fly | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 || 8 | dfdg | d124 | NULL || 9 | dgdg | 123r | NULL |+-----+----------+----------+-------+6 rows in set (0.00 sec) 定位元字符：元字符 说明 ^ 文本的开始 $ 文本的结尾 [[:&lt;:]] 词的开始 [[:&gt;:]] 词的结尾 示例:找出密码中以数字开头的记录：12345678910111213141516171819202122232425mysql&gt; SELECT uid,username,password,state FROM user WHERE password REGEXP &quot;^[[:digit:]\\\\.]&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 4 | test1 | 123 | 0 || 3 | fly | 123 | 0 || 5 | test2 | 123 | 0 || 6 | test3 | 123 | 1 || 7 | 1 | 1 | 1 || 9 | dgdg | 123r | NULL || 10 | gdg | 1d23 | NULL || 11 | dgdgh | 1.23s | NULL || 12 | dgklds | 2.31t | NULL |+-----+----------+----------+-------+9 rows in set (0.00 sec)// 注意区别mysql&gt; SELECT uid,username,password,state FROM user WHERE password REGEXP &quot;^[:digit:]\\\\.&quot;;+-----+----------+----------+-------+| uid | username | password | state |+-----+----------+----------+-------+| 11 | dgdgh | 1.23s | NULL || 12 | dgklds | 2.31t | NULL |+-----+----------+----------+-------+2 rows in set (0.00 sec) 创建计算字段Concat（）函数拼接字段 Concat（）拼接串，把多个串连接起来形成一个较长的串。各串之间用“，”分隔。 注:多数DBMS使用+或||来实现拼接,而mysql使用Concat（）函数 将用户名按用户名（用户id）拼接出来：12345678910mysql&gt; SELECT Concat(username,'(',uid,')') FROM user ORDER BY uid DESC LIMIT 4;+------------------------------+| Concat(username,'(',uid,')') |+------------------------------+| test6(24) || test5(23) || test4(22) || kgdlksgj(21) |+------------------------------+4 rows in set (0.00 sec) RTrim( )函数：删除值右边的所有空格12345678910mysql&gt; SELECT Concat(Rtrim(username),'(',uid,')') FROM user ORDER BY uid DESC LIMIT 4;+-------------------------------------+| Concat(Rtrim(username),'(',uid,')') |+-------------------------------------+| test6(24) || test5(23) || test4(22) || kgdlksgj(21) |+-------------------------------------+4 rows in set (0.00 sec) LTrim( )函数去掉串左边的空格，Trim( )函数去掉串两边的空格； 使用别名： 别名（alias）用AS关键字赋予，使用别名能让客户机更好的使用数据，别名有时也叫导出列； 123456789101112mysql&gt; SELECT Concat(username,'(',uid,')') -&gt; AS uinfo -&gt; FROM user LIMIT 4;+----------+| uinfo |+----------+| test1(4) || fly(3) || test2(5) || test3(6) |+----------+4 rows in set (0.00 sec)","link":"/2021/10/11/MySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E7%AC%94%E8%AE%B01/"}],"tags":[{"name":"SQL","slug":"SQL","link":"/tags/SQL/"},{"name":"http","slug":"http","link":"/tags/http/"},{"name":"正则","slug":"正则","link":"/tags/%E6%AD%A3%E5%88%99/"}],"categories":[{"name":"网络","slug":"网络","link":"/categories/%E7%BD%91%E7%BB%9C/"},{"name":"Blog","slug":"Blog","link":"/categories/Blog/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"学习笔记","slug":"学习笔记","link":"/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"}]}