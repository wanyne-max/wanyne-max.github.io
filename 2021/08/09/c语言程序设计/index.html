<!doctype html>
<html lang="zh"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>c语言程序设计 - Wanyne&#039;s Blog</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Wanyne&#039;s Blog"><meta name="msapplication-TileImage" content="/img/favicon.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Wanyne&#039;s Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="C语言复习过程：1.看基础视频，过一遍王敬华的C语言PPT，对C语言可能涉及的内容有个整体的了解；2.看王敬华的C语言教材，C语言教材一定要用王敬华的，最近几年很多真题出自王敬华教材，这本教材必须做的烂熟；3.做王敬华给本科生的题库，做官方渠道传出的C复习题，做本科生C语言实验课题和期末上机题库；4.看C语言详细笔记做最后巩固，翻看往年真题；5.对知识点做一个完整的回顾；6.最后对上述做的题，做一"><meta property="og:type" content="blog"><meta property="og:title" content="c语言程序设计"><meta property="og:url" content="https://wanyne-max.github.io/2021/08/09/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><meta property="og:site_name" content="Wanyne&#039;s Blog"><meta property="og:description" content="C语言复习过程：1.看基础视频，过一遍王敬华的C语言PPT，对C语言可能涉及的内容有个整体的了解；2.看王敬华的C语言教材，C语言教材一定要用王敬华的，最近几年很多真题出自王敬华教材，这本教材必须做的烂熟；3.做王敬华给本科生的题库，做官方渠道传出的C复习题，做本科生C语言实验课题和期末上机题库；4.看C语言详细笔记做最后巩固，翻看往年真题；5.对知识点做一个完整的回顾；6.最后对上述做的题，做一"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.5aa96txrgls0.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/%E4%B8%80%E4%BA%9B%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7.1p9t1feafytc.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/scanf%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.5vs30pin6jw0.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/printf%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.7ka7f4lqji00.png"><meta property="article:published_time" content="2021-08-09T04:13:41.000Z"><meta property="article:modified_time" content="2021-08-10T04:21:35.329Z"><meta property="article:author" content="Wanyne W"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.5aa96txrgls0.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://wanyne-max.github.io/2021/08/09/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"},"headline":"c语言程序设计","image":["https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.5aa96txrgls0.png","https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/%E4%B8%80%E4%BA%9B%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7.1p9t1feafytc.png","https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/scanf%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.5vs30pin6jw0.png","https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/printf%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.7ka7f4lqji00.png"],"datePublished":"2021-08-09T04:13:41.000Z","dateModified":"2021-08-10T04:21:35.329Z","author":{"@type":"Person","name":"Wanyne W"},"publisher":{"@type":"Organization","name":"Wanyne's Blog","logo":{"@type":"ImageObject","url":"https://wanyne-max.github.io/img/logo.svg"}},"description":"C语言复习过程：1.看基础视频，过一遍王敬华的C语言PPT，对C语言可能涉及的内容有个整体的了解；2.看王敬华的C语言教材，C语言教材一定要用王敬华的，最近几年很多真题出自王敬华教材，这本教材必须做的烂熟；3.做王敬华给本科生的题库，做官方渠道传出的C复习题，做本科生C语言实验课题和期末上机题库；4.看C语言详细笔记做最后巩固，翻看往年真题；5.对知识点做一个完整的回顾；6.最后对上述做的题，做一"}</script><link rel="canonical" href="https://wanyne-max.github.io/2021/08/09/c%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"><link rel="icon" href="/img/favicon.png"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.15.2/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.4.0"></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Wanyne&#039;s Blog" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">主页</a><a class="navbar-item" href="/archives">归档</a><a class="navbar-item" href="/categories">分类</a><a class="navbar-item" href="/tags">标签</a><a class="navbar-item" href="/about">关于</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="搜索" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><time dateTime="2021-08-09T04:13:41.000Z" title="2021/8/9 下午12:13:41">2021-08-09</time>发表</span><span class="level-item"><time dateTime="2021-08-10T04:21:35.329Z" title="2021/8/10 下午12:21:35">2021-08-10</time>更新</span><span class="level-item"><a class="link-muted" href="/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/">考研复习</a></span><span class="level-item">1 小时读完 (大约7625个字)</span></div></div><h1 class="title is-3 is-size-4-mobile">c语言程序设计</h1><div class="content"><p>C语言复习过程：<br>1.看基础视频，过一遍王敬华的C语言PPT，对C语言可能涉及的内容有个整体的了解；<br>2.看王敬华的C语言教材，C语言教材一定要用王敬华的，最近几年很多真题出自王敬华教材，这本教材必须做的烂熟；<br>3.做王敬华给本科生的题库，做官方渠道传出的C复习题，做本科生C语言实验课题和期末上机题库；<br>4.看C语言详细笔记做最后巩固，翻看往年真题；<br>5.对知识点做一个完整的回顾；<br>6.最后对上述做的题，做一个错题集，在考前有针对性地看下。</p>
<p><escape><span id="more"></span></escape></p>
<h1 id="1、各种运算符、优先级和结合性"><a href="#1、各种运算符、优先级和结合性" class="headerlink" title="1、各种运算符、优先级和结合性"></a>1、各种运算符、优先级和结合性</h1><h2 id="运算符优先级和结合性一览表"><a href="#运算符优先级和结合性一览表" class="headerlink" title="运算符优先级和结合性一览表"></a>运算符优先级和结合性一览表</h2><p><img src="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7.5aa96txrgls0.png" alt="运算符优先级"></p>
<p>上表中可以总结出如下规律：</p>
<ol>
<li>结合方向只有三个是从右往左，其余都是从左往右。</li>
<li>所有双目运算符中只有赋值运算符的结合方向是从右往左。</li>
<li>另外两个从右往左结合的运算符也很好记，因为它们很特殊：一个是单目运算符，一个是三目运算符。</li>
<li>C语言中有且只有一个三目运算符。</li>
<li>逗号运算符的优先级最低，要记住。</li>
<li>此外要记住，对于优先级：算术运算符 &gt; 关系运算符 &gt; 逻辑运算符 &gt; 赋值运算符。逻辑运算符中“逻辑非 !”除外。</li>
</ol>
<h2 id="一些容易出错的优先级问题"><a href="#一些容易出错的优先级问题" class="headerlink" title="一些容易出错的优先级问题"></a>一些容易出错的优先级问题</h2><p>上表中，优先级同为1 的几种运算符如果同时出现，那怎么确定表达式的优先级呢？下表就整理了这些容易出错的情况：</p>
<p><img src="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/%E4%B8%80%E4%BA%9B%E5%AE%B9%E6%98%93%E5%87%BA%E9%94%99%E7%9A%84%E4%BC%98%E5%85%88%E7%BA%A7.1p9t1feafytc.png" alt="一些容易出错的优先级"></p>
</br>

<h1 id="2、数据类型及与表示范围"><a href="#2、数据类型及与表示范围" class="headerlink" title="2、数据类型及与表示范围"></a>2、数据类型及与表示范围</h1><h2 id="有符号整数类型"><a href="#有符号整数类型" class="headerlink" title="有符号整数类型"></a>有符号整数类型</h2><table>
<thead>
<tr>
<th align="center">类型名称</th>
<th align="center">字节数</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">signed char</td>
<td align="center">1</td>
<td align="center">-2<sup>7</sup> (-128) ~ 2<sup>7</sup>-1 (127)</td>
</tr>
<tr>
<td align="center">short int 或 short</td>
<td align="center">2</td>
<td align="center">-2<sup>15</sup> (-32 768) ~ 2<sup>15</sup>-1 (32 767)</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-2<sup>31</sup> (-2 147 483 648) ~ 2<sup>31</sup>-1(2 147 483 647)</td>
</tr>
<tr>
<td align="center">long int 或 long</td>
<td align="center">4</td>
<td align="center">-2<sup>31</sup> (-2 147 483 648) ~ 2<sup>31</sup>-1 (2 147 483 647)</td>
</tr>
<tr>
<td align="center">long long int 或 long long</td>
<td align="center">8</td>
<td align="center">-2<sup>63</sup> (-9.2233720368548e+18) ~ 2<sup>63</sup>-1 (9.2233720368548e+18)</td>
</tr>
</tbody></table>
</br>

<h2 id="无符号整数类型"><a href="#无符号整数类型" class="headerlink" title="无符号整数类型"></a>无符号整数类型</h2><table>
<thead>
<tr>
<th align="center">类型名称</th>
<th align="center">字节数</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">unsigned char</td>
<td align="center">1</td>
<td align="center">0 ~ 2<sup>8</sup>-1 (255)</td>
</tr>
<tr>
<td align="center">unsigned short int 或 unsigned short</td>
<td align="center">2</td>
<td align="center">0 ~ 2<sup>16</sup>-1 (65 535)</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">4</td>
<td align="center">0 ~ 2<sup>32</sup>-1 (4 294 967 295)</td>
</tr>
<tr>
<td align="center">unsigned long int 或 unsigned long</td>
<td align="center">4</td>
<td align="center">0 ~ 2<sup>32</sup>-1 (4 294 967 295)</td>
</tr>
<tr>
<td align="center">unsigned long long int 或 unsigned long long</td>
<td align="center">8</td>
<td align="center">0 ~ 2<sup>64</sup>-1 (1.844674407371e+19)</td>
</tr>
</tbody></table>
</br>

<h2 id="浮点类型"><a href="#浮点类型" class="headerlink" title="浮点类型"></a>浮点类型</h2><table>
<thead>
<tr>
<th align="center">类型名称</th>
<th align="center">字节数</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">-/+3.4e38（精确到6位小数）</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">8</td>
<td align="center">-/+1.7e308（精确到15位小数）</td>
</tr>
<tr>
<td align="center">long double</td>
<td align="center">12</td>
<td align="center">-/+1.19e4932（精确到18位小数）</td>
</tr>
</tbody></table>
</br>

<h1 id="3、格式化输入、输出"><a href="#3、格式化输入、输出" class="headerlink" title="3、格式化输入、输出"></a>3、格式化输入、输出</h1><h2 id="格式化输入——scanf函数"><a href="#格式化输入——scanf函数" class="headerlink" title="格式化输入——scanf函数"></a>格式化输入——scanf函数</h2><p>具有<code>变长</code>参数表的函数scanf的声明形式如下：</p>
<p><code>int scanf(char *format, ...)</code></p>
<p>scanf函数从标准输入中读取字符序列，按照format中的格式说明对字符序列进行解释，并把结果保存到其余的参数中。其他所有参数必须是<code>指针</code>，用于指定经格式转换后的相应输入保存的位置。</p>
<p>当scanf函数扫描完其格式串，或者碰到某些输入无法与格式控制说明匹配的情况时，该函数将终止，同时，成功匹配并赋值的输入项的个数将作为函数值返回，所有，该函数的返回值可以用来确定已匹配的输入项的个数。如果到达文件的结尾，该函数将返回EOF。注意，返回EOF与0是不同的，0表示下一个输入字符与格式串中的第一个格式说明不匹配。下一次调用scanf函数将从上一次转换的最后一个字符的下一个字符s开始继续搜索。</p>
<p>另外还有一个输入函数<code>sscanf</code>,它用于从一个<code>字符串</code>(而不是标准输入)中读取字符序列:</p>
<p><code>int sscanf(char *string, char *format, arg1, arg2...)</code></p>
<p>它按照格式参数format中规定的格式扫描字符串string,并把结果分别保存到arg1、Iarg2、..这些参数中。这些参数必须是指针。</p>
<p>格式串通常都包含转换说明，用于控制输入的转换。格式串可能包含下列部分:</p>
<ul>
<li><p>空格或制表符，在处理过程中将被忽略。</p>
</li>
<li><p>普通字符(不包括%)，用于匹配输入流中下一个非空白符字符。</p>
</li>
<li><p>转换说明，依次由一个%、一个可选的赋值禁止字符*、一个可选的数值(指定最大字段宽度)、一个可选的h、1或L字符(指定目标对象的宽度)以及一个转换字符组成。</p>
</li>
</ul>
<p>转换说明控制下一个输入字段的转换。一般来说，转换结果存放在相应的参数指向的变量中。但是，如果转换说明中有赋值禁止字符*，则跳过该输入字段，不进行赋值。输入字段定义为一个不包括空白符的字符串，其边界定义为到下一个空白符或达到指定的字段宽度。这表明scanf函数将越过行边界读取输入，因为换行符也是空白符。(空白符包括空格符、横向制表符、换行符、回车符、纵向制表符以及换页符)。</p>
<p>转换字符指定对字段的解释。对应的参数必须时指针，这也是C语言通过值调用语义所要求的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/scanf%E5%87%BD%E6%95%B0%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.5vs30pin6jw0.png" alt="scanf函数的基本转换说明"></p>
<p>转换说明d、i、o、u及x的前面可以加上字符h或l。前缀h表明参数表的相应参数是一个指向short类型而非int类型的指针,前缀l表明参数表的相应参数是一个指向long类型的指针。类似地，转换说明e、f和g的前面也可以加上前缀l,它表明参数表的相应参数是一个指向double类型而非float类型的指针。</p>
</br>

<h2 id="格式化输出——printf函数"><a href="#格式化输出——printf函数" class="headerlink" title="格式化输出——printf函数"></a>格式化输出——printf函数</h2><p>输出函数printf将内部数值转换为字符的形式。</p>
<p><code>int printf (char *format, arg1,arg2, ...);</code></p>
<p>函数printf在输出格式format的控制下，将其参数进行转换与格式化，并在标准输出设备上打印出来。它的返回值为打印的字符数。</p>
<p>格式字符串包含两种类型的对象:普通字符和转换说明。在输出时，普通字符将原样不动地复制到输出流中，而转换说明并不直接输出到输出流中，而是用于控制printf中参数的转换和打印，每个转换说明都由一个百分号字符(即%)开始，并以一个转换字符结束。在字符%和转换字符中间可能依次包含下列组成部分:</p>
<ul>
<li><p>负号，用于指定被转换的参数按照左对齐的形式输出。</p>
</li>
<li><p>数，用于指定最小字段宽度。转换后的参数将打印不小于最小字段宽度的字段。如果有必要，字段左边(如果使用左对齐的方式，则为右边)多余的字符位置用空格填充以保证最小字段宽。</p>
</li>
<li><p>小数点，用于将字段宽度和精度分开。</p>
</li>
<li><p>数，用于指定精度，即指定字符串中要打印的最大字符数、浮点数小数点后的位数、整型最少输出的数字数目。</p>
</li>
<li><p>字母h或l，字母h表不将整数l作为short类l型打印，字母l表示将整数作为long类型打印。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/wanyne-max/image-host@master/c%E8%AF%AD%E8%A8%80/printf%E5%87%BD%E6%95%B0%E5%9F%BA%E6%9C%AC%E8%BD%AC%E6%8D%A2%E8%AF%B4%E6%98%8E.7ka7f4lqji00.png" alt="printf函数基本转换说明"></p>
<p>下表说明了在打印字符串”hello, world” (12个字符)时根据不同的转换说明产生的不同结果。我们在每个字段的左边和右边加上冒号，这样可以清晰地表示出字段的宽度。</p>
<p>:%s:   &nbsp;&nbsp; &nbsp; &nbsp;:hello, world:</p>
<p>:%10s:  &nbsp; &nbsp;:hello, world:</p>
<p>:%.10s:  &nbsp; &nbsp;:hello, wor:</p>
<p>:%-10s:  &nbsp; &nbsp;:hello, world:</p>
<p>:%.15s:  &nbsp; &nbsp;:hello, world:</p>
<p>:%-15s:  &nbsp; &nbsp;:hello, world :</p>
<p>:%15.10s:  &nbsp; &nbsp;: &nbsp; &nbsp; &nbsp;hello, wor:(与下列o对齐)</p>
<p>:%-15.10s:  &nbsp;:hello, wor :</p>
<p>函数sprintf执行的转换和函数printf相同，但它将输出保存到一个字符串中:</p>
<p><code>int sprintf (char. *string, char *format, arg1， arg2, ... )</code></p>
<p>sprintf函数和printf函数一样，按照format格式格式化参数序列arg1、arg2、但它将输出结果存放到str ing中，而不是输出到标准输出中。当然，string必须足够大以存放输出结果。</p>
</br>


<h1 id="4、程序的控制结构及应用"><a href="#4、程序的控制结构及应用" class="headerlink" title="4、程序的控制结构及应用"></a>4、程序的控制结构及应用</h1><h2 id="程序结构："><a href="#程序结构：" class="headerlink" title="程序结构："></a>程序结构：</h2><p>在C语言程序中，一共有三种程序结构：顺序结构、选择结构(分支结构)、循环结构；</p>
<p><code>顺序结构</code>：从头到尾一句接着一句的执行下来，直到执行完最后一句；</p>
<p><code>选择结构</code>：到某个节点后，会根据一次判断的结果来决定之后向哪一个分支方向执行；</p>
<p><code>循环结构</code>：循环结构有一个循环体，循环体里是一段代码。对于循环结构来说，关键在于根据判断的结果，来决定循环体执行多少次；</p>
<p>　　注：在逻辑上有一种bool类型(也叫boolean类型，布尔类型)，只有两个值，即真和假。C语言的判断表达式最终的值就是一个bool类型，这个判断表达式的bool值就决定了选择结构如何选择，循环结构如何循环；</p>
<h2 id="顺序结构："><a href="#顺序结构：" class="headerlink" title="顺序结构："></a>顺序结构：</h2><p>顺序结构很简单，一般我们遇到的除了选择结构和循环结构外，都是顺序结构；</p>
<h2 id="选择结构："><a href="#选择结构：" class="headerlink" title="选择结构："></a>选择结构：</h2><p>C语言中常用的选择结构主要有以下两种：</p>
<h3 id="1-if-else：引入关键字：if-else-else-if"><a href="#1-if-else：引入关键字：if-else-else-if" class="headerlink" title="(1) if else：引入关键字：if　　else　　else if"></a><strong>(1) if else：引入关键字：if　　else　　else if</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">　　　　if (bool值) 　　　　// 如果bool值为真，则执行代码段1，否则执行代码段2</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　代码段1</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　else</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　代码段2</span><br><span class="line">　　　　&#125;</span><br><span class="line"></span><br><span class="line">　　　　if (bool值1)　　　　// 如果bool值1为真，则执行代码段1，否则判断bool值2是否为真</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　代码段1</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　else if (bool值2)　　// 若bool值2为真则执行代码段2，否则直接执行代码段3</span><br><span class="line">　　　　&#123;　　　　　　　　　　// 开头的if和结尾的else都只能有一个，但是中间的else if可以有好多个</span><br><span class="line">　　　　　　代码段2</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　　　else</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　代码段3</span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-switch-case：引入关键字：switch-case-break-default"><a href="#2-switch-case：引入关键字：switch-case-break-default" class="headerlink" title="(2) switch case：引入关键字：switch　　case　　break　　default"></a><strong>(2) switch case：引入关键字：switch　　case　　break　　default</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">　　　　switch (变量) 　　　　　　// 执行到这一句时，变量的值是已知的</span><br><span class="line">　　　　&#123; 　　　　　　　　　　　　// switch case语句执行时，会用该变量的值依次与各个case后的常数去对比，试图找到第一个匹配项，找到匹配的项目后，</span><br><span class="line">　　　　 　　case 常数1: 　　　　　　// 就去执行该case对应的代码段，如果没找到则继续下一个case，直到default</span><br><span class="line">　　　　 　　　　代码段1;　　　　　　　　// 如果前面的case都未匹配，则default匹配。</span><br><span class="line"></span><br><span class="line">　　　　 　　　　break;</span><br><span class="line"></span><br><span class="line">　　　　　 　case 常数2:  </span><br><span class="line">　　　　 　　　　代码段2;</span><br><span class="line">　　　　 　　　　break;</span><br><span class="line">　　　　 　　……</span><br><span class="line"></span><br><span class="line">　　　　 　　default:</span><br><span class="line">　　　　 　　　　代码段n;</span><br><span class="line">　　　　 　　　　break;</span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure>
<p>注：第一，case中必须是常数，而且必须是整形；</p>
<p>第二，一般来说，每个case中代码段后都必须有一个break；</p>
<p>第三，case之后一般都会有default，虽然语法上允许没有default，但是建议写代码时一定要写；</p>
<h3 id="3-if-else和switch-case的区别："><a href="#3-if-else和switch-case的区别：" class="headerlink" title="(3) if else和switch case的区别："></a><strong>(3) if else和switch case的区别：</strong></h3><p>if else适合对比条件较复杂，但是分支比较少的情况，switch case适合那种对比条件简单，但是分支较多的情况；</p>
<p>通常的做法是：在适合使用switch case的情况下会优先使用switch case，如果不适合则使用if else；</p>
<h2 id="循环结构："><a href="#循环结构：" class="headerlink" title="循环结构："></a>循环结构：</h2><p>C语言中常用的循环结构主要有以下三种：</p>
<h3 id="1-for："><a href="#1-for：" class="headerlink" title="(1) for："></a><strong>(1) for：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">　　　　for (循环控制变量初始化; 循环终止条件; 循环控制变量增量)</span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　循环体</span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure>
<p>循环执行步骤：</p>
<p>第一，先进行循环控制变量初始化；</p>
<p>第二，执行循环终止条件，如果判断结果为真，则进入第三步；如果为假则循环终止并退出；</p>
<p>第三，执行循环体；</p>
<p>第四，执行循环控制变量增量，转入第二步；</p>
<p>注：for循环()中的三部分除了循环终止条件外，其他两部分都可以省略，但标准的for循环中，应该把循环控制变量的初始化，增量都放在()当中，并且在循环体中绝对不应该更改循环控制变量；</p>
<h3 id="2-while："><a href="#2-while：" class="headerlink" title="(2) while："></a><strong>(2) while：</strong></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">　　　　循环控制变量初始化</span><br><span class="line"></span><br><span class="line">　　　　while(循环终止条件)</span><br><span class="line"></span><br><span class="line">　　　　&#123;</span><br><span class="line">　　　　　　循环体</span><br><span class="line"></span><br><span class="line">　　　　　　循环控制变量增量</span><br><span class="line"></span><br><span class="line">　　　　&#125;</span><br></pre></td></tr></table></figure>

<p>循环执行步骤：</p>
<p>第一，先进行循环控制变量初始化(在while之前)；</p>
<p>第二，判断循环终止条件，如果判断结果为真，则进入第三步；如果为假则不执行循环体；</p>
<p>第三，执行循环体；</p>
<p>第四，执行循环控制变量增量，转入第二步；</p>
<h3 id="3-do-while："><a href="#3-do-while：" class="headerlink" title="(3) do while："></a><strong>(3) do while：</strong></h3><p>循环执行步骤：第一，先进行循环控制变量初始化(在do while之前)；</p>
<p>第二，执行循环体；</p>
<p>第三，执行循环控制变量增量；</p>
<p>第四，判断循环终止条件，如果判断结果为真，则返回第二步；如果为假则直接退出循环；</p>
<p>(4) 总结：不管哪种循环结构，都不能缺少循环控制条件初始化，终止条件，循环控制变量增量，循环体这四部分；</p>
<p>while循环是先判断后执行，do while循环是先执行后判断，等循环一次之后，其实都是一样的；</p>
</br>

<h1 id="5、函数参数的传递方式"><a href="#5、函数参数的传递方式" class="headerlink" title="5、函数参数的传递方式"></a>5、函数参数的传递方式</h1><p>函数参数传递三种方式（传值方式，地址传递，引用传递）</p>
<h2 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h2><p>形参即形式上的参数，对实参的一种抽象类型描述只是声明一个函数能够接受什么类型的实参，而不确定接受的实参的具体内容是什么</p>
<p>实参即传递给函数对应形参的具体内容</p>
<h2 id="参数传递两种方式–传值-amp-传址"><a href="#参数传递两种方式–传值-amp-传址" class="headerlink" title="参数传递两种方式–传值&amp;传址"></a>参数传递两种方式–传值&amp;传址</h2><p><code>传值方式</code>：将实参的值拷贝给函数或方法，在函数内对形参进行操作，操作的对象是实参的拷贝，对实参本身没有影响，在函数结束返回后，形参被丢弃释放，实参的内容不会被改变</p>
<p><code>传址方式</code>：将实参的地址传递给函数，在函数内对形参进行操作等同于对实参进行相同的操作，在函数调用结束返回后，形参被释放，实参的内容是对形参进行操作后的结果。<br>传址又分为：引用传递&amp;指针传递</p>
<h2 id="1-值传递"><a href="#1-值传递" class="headerlink" title="1.值传递"></a>1.值传递</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void exchange1(int x,int y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>exchange1(a,b);在调用过程中，函数隐含的把实参a,b的值分别传给了x,y 函数中的操作只是对，xy的操作，没有对a,b 进行任何操作，因此啊，ab的值是不变的。</p>
<h2 id="2-地址传递（指针）"><a href="#2-地址传递（指针）" class="headerlink" title="2.地址传递（指针）"></a>2.地址传递（指针）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void exchange2(int *px,int *py)</span><br><span class="line">&#123;</span><br><span class="line">    int temp=*px;</span><br><span class="line">    *px=*py;</span><br><span class="line">    *py=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a=4,b=5;</span><br><span class="line">exchange2(&amp;a,&amp;b);</span><br></pre></td></tr></table></figure>
<p>　　将ab的地址传递给函数，对*px,*py的操作即是对a,b变量本身的操作。可以实现a,b的值交换</p>
<h2 id="3-引用传递"><a href="#3-引用传递" class="headerlink" title="3.引用传递"></a>3.引用传递</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void exchange3(int &amp;x,int &amp;y)</span><br><span class="line">&#123;</span><br><span class="line">    int temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br><span class="line">int a=3,b=4;</span><br><span class="line">exchange3(a,b);</span><br></pre></td></tr></table></figure>
<p>　　仅形式参数的格式与值传递不同，内部定义域调用与值传递完全相同，可以实现ab值得对调</p>
<p>　　因为在x,y 前有一个取地址符号&amp;，在调用exchang3(a,b)时会用替换x,y,称xy引用了变量ab,在函数内部便是对实参ab进行操作了，函数 内部可以直接修改a,b的值。</p>
<p> 引用即对象的别名，传对象的引用，用于把一个对象的地址作为参数传递过去，而不是对象本身。引用传递，避免了一次实参到形参的拷贝，提高了效率。</p>
</br>

<h2 id="引用，指针，传址使用原则"><a href="#引用，指针，传址使用原则" class="headerlink" title="引用，指针，传址使用原则"></a>引用，指针，传址使用原则</h2><ol>
<li>如果数据对象较小，如内置数据类型或小型结构，则按值传递</li>
<li>如果数据对象是数组，则使用指针，并将指针声明为指向const的指针</li>
<li>如果数据对象是较大的结构，则使用const指针或const引用，以提高运行效率，以减少复制结构所需要的时间和空间</li>
<li>如果数据对象是类对象，则使用const引用，传递类对象参数的标准方式是按引用传递。</li>
<li>如果出现类似的manmin(&amp;x),其中x为int类型的值，那么函数将修改变量x的值。</li>
</ol>
</br>

<h1 id="6、变量的作用域与生存期"><a href="#6、变量的作用域与生存期" class="headerlink" title="6、变量的作用域与生存期"></a>6、变量的作用域与生存期</h1><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p><code>作用域</code>描述了程序中可以访问一个标识符的一个或多个区域，一个C变量的作用域可以是代码块作用域、函数原型作用域，或者文件作用域。代码块是包含在一对花括号`内的一段代码，在代码块中定义的变量具有代码块作用域，从该变量被定义的地方到包含该定义的代码块的末尾该变量均可见，但只局限于代码块。因此，函数作用域也属于代码块作用域。</p>
<p>一个在所有函数之外定义的变量具有文件作用域，从定义开始到包含该文件结尾都可见，文件作用域变量也称为全局变量。</p>
<h2 id="生存期"><a href="#生存期" class="headerlink" title="生存期"></a>生存期</h2><p>一个C变量有两种生存期：<code>静态生存期</code>和<code>自动生存期</code>。一个静态变量在程序执行期间将一直存在，一个自动变量在作用域结束后内存将释放。</p>
<p>一般使用 static 声明变量的静态生存期，而对于文件作用域变量，都具有静态生存期。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int lint = 1;   // lint 具有文件作用域、静态生存期</span><br><span class="line">void print(int data)</span><br><span class="line">&#123;</span><br><span class="line">    int i, *p;  // 作用域开始，局部变量</span><br><span class="line">    for(i=0; i&lt;lint; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        static int temp = 1;    // 具有代码块作用域、静态生存期</span><br><span class="line">        int pd = data * i;  // pd作用域开始</span><br><span class="line">        . . .</span><br><span class="line">        temp++;</span><br><span class="line">        p = &amp;temp;  // p指向temp所在地址</span><br><span class="line">        printf(“data = %d\t”, pd);</span><br><span class="line">    &#125;   // pd作用域结束</span><br><span class="line">    . . .</span><br><span class="line">    // printf(“temp = %s\n”, temp); // 错误，temp 已离开作用域</span><br><span class="line">    printf(“temp = %s\n”, *p);  // 正确，temp 不可见，但是一直存在，其地址也可用</span><br><span class="line">&#125;   // i 作用域结束</span><br></pre></td></tr></table></figure>

<h3 id="1-具有代码块作用域的静态变量"><a href="#1-具有代码块作用域的静态变量" class="headerlink" title="1.具有代码块作用域的静态变量"></a><strong>1.具有代码块作用域的静态变量</strong></h3><p>未经初始化的全局静态变量会被程序自动初始化为0（自动对象的值是任意的，除非被显示初始化）。</p>
<p>在调用包含具有代码块作用域静态变量的函数时，由于其一直存在，因此在每次调用时print（）函数时，其它自动变量都被初始化，而temp只在编译print（）时初始化一次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    int c;</span><br><span class="line">    for(c=0;c&lt;=3;c++)</span><br><span class="line">    &#123;</span><br><span class="line">        print(1);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回下列结果</p>
<p>data = 1      temp = 2</p>
<p>data = 1      temp = 3</p>
<p>data = 1      temp = 4</p>
<h3 id="2-返回字符串的函数"><a href="#2-返回字符串的函数" class="headerlink" title="2.返回字符串的函数"></a><strong>2.返回字符串的函数</strong></h3><p>在调用返回字符串的函数时，有时候返回的是垃圾信息。例如下面的程序</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">char *itoa(int n)</span><br><span class="line">&#123;</span><br><span class="line">    char retbuf[20]; // 错！ </span><br><span class="line">    sprintf(retbuf, &quot;%d&quot;, n);</span><br><span class="line">    return retbuf; // 错！</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为局部数组在函数调用完成之后，堆栈的空间将释放，因而返回指向数组的指针无效。</p>
<p>一种解决方案是把缓冲区声明成静态生存期，这样在程序运行期间局部数组将一直存在</p>
<p><code>static char retbuf[20];</code></p>
<p>另一种解决方案是使用 malloc申请动态内存空间</p>
<p><code>char * retbuf = malloc(20);</code></p>
<p>虽然指针retbuf 是局部变量，离开调用函数后将被释放，但是申请的内存空间在没有使用 free之前将一直存在。因此也可能产生了一个问题：申请的内存空间没有被释放，可行的方法是用完返回的字符指针之后，使用free将该地址处的内存释放，前提是这个指针没有移动。</p>
<h3 id="3-static-与全局变量"><a href="#3-static-与全局变量" class="headerlink" title="3.static 与全局变量"></a><strong>3.static 与全局变量</strong></h3><p>由于全局变量自动具有静态生存期，在全局变量之前加上 static，表示全局变量的链接方式。</p>
<p>具有外部链接的全局变量，其他文件可以使用；具有部链接的全局变量，属于文件私有，但是可以被该文件中的任一函数使用。为了使程序更加清晰，可以在使用全局变量的函数中通过使用关键字extern 来再次声明它。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// file1.c</span><br><span class="line">int giant = 5;  // 全局变量，外部链接</span><br><span class="line">static int dodg = 3;    // 全局变量，内部链接</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern int giant;   // 可选的声明</span><br><span class="line">    extern int dodg;    // 可选的声明</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果变量是在别的文件中定义的，使用 extern来声明该变量是必须的。其它文件中引用声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// file2.c</span><br><span class="line">static int dodg = 3;    // 可以</span><br><span class="line">int giant = 5;      // 命名冲突，在file1.c中已经定义了      </span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">    extern int giant;   // 必须的声明</span><br><span class="line">    // extern int dodg; // 错误的声明，因为dodg为内部链接</span><br><span class="line">    . . .</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>两个具有相同名称的外部对象实际上代表的是同一个对象，当在两个不同源文件中都包括了一个相同的定义，那么这将表示程序错误（如果连接器禁止外部变量重复定义的话），或者两个源文件共享同一个实例。为了避免这类命名冲突的问题，static是一个有用的工具。</p>
<p><code>注意</code>：当static用来修饰局部变量的时候，它就改变了局部变量的存储位置，从原来的栈中存放改为静态存储区。但是局部静态变量在离开作用域之后，并没有被销毁，而是仍然驻留在内存当中，直到程序结束，只不过我们不能再对他进行访问。</p>
<h3 id="4-静态函数"><a href="#4-静态函数" class="headerlink" title="4.静态函数"></a><strong>4.静态函数</strong></h3><p>在函数的返回类型前加上关键字static，函数就被定义成为静态函数。</p>
<p>函数的定义和声明默认情况下是extern的，与具有内部链接的全局变量一样，静态函数只是在声明它的文件当中可见，不能被其他文件所用。例如</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// file1.c</span><br><span class="line">void dis();</span><br><span class="line">static void static_dis(); </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    dis();</span><br><span class="line">    static_dis();</span><br><span class="line">    renturn 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// file2.c</span><br><span class="line">	</span><br><span class="line">void dis()</span><br><span class="line">&#123;</span><br><span class="line">    static_dis();</span><br><span class="line">&#125;</span><br><span class="line">static void static_dis()</span><br><span class="line">&#123;</span><br><span class="line">    printf(&quot;static_dis() of file2.c has been called/n&quot;);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>文件分别编译通过，但是连接的时候找不到函数static_dis（）的定义，产生错误。</p>
<p>定义静态函数的好处：其他文件中可以定义相同名字的函数，不会发生冲突</p>
</br>

<h1 id="7、变量的存储类型"><a href="#7、变量的存储类型" class="headerlink" title="7、变量的存储类型"></a>7、变量的存储类型</h1><p>在C语言中，对变量的存储类型说明有以下四种：</p>
<p>auto　　　　 自动变量</p>
<p>register　　 &nbsp;&nbsp;寄存器变量</p>
<p>extern　　　 外部变量</p>
<p>static　　　 &nbsp; 静态变量</p>
<p>自动变量和寄存器变量属于<code>动态存储</code>方式，外部变量和静态变量属于<code>静态存储</code>方式。</p>
<p>在介绍了变量的存储类型之后，可以知道对一个<code>变量的说明</code>不仅应说明其<code>数据类型</code>，还应说明其<code>存储类型</code>。</p>
<p>因此变量说明的完整形式应为：存储类型说明符数据类型说明符变量名，变量名…；例如：</p>
<p>　　static int a,b;　　　　　　　　说明a,b为静态类型变量</p>
<p>　　auto char c1,c2;　　　　　　　说明c1,c2为自动字符变量</p>
<p>　　static int a[5]={1,2,3,4,5};　　　       说明a为静整型数组</p>
<p>　　extern int x,y;　　　　　　　　说明x,y为外部整型变量</p>
</br>

<p>下面分别介绍以上四种存储类型：</p>
<h2 id="一、自动变量的类型说明符为auto（缺省的符号，不写就是默认auto）"><a href="#一、自动变量的类型说明符为auto（缺省的符号，不写就是默认auto）" class="headerlink" title="一、自动变量的类型说明符为auto（缺省的符号，不写就是默认auto）"></a>一、自动变量的类型说明符为auto（缺省的符号，不写就是默认auto）</h2><p>　　这种存储类型是C语言程序中使用最广泛的一种类型。C语言规定，函数内凡未加存储类型说明的变量均视为自动变量，也就是说自动变量可省去说明符auto。</p>
<p>　　自动变量的作用域仅限于定义该变量的个体内。在函数中定义的自动变量，只在该函数内有效。在<code>复合语句</code>中定义的自动变量只在该复合语句中有效。</p>
<p>　　自动变量属于动态存储方式，只有在使用它，即<code>定义该变量的函数被调用时才给它分配存储单元</code>，开始它的<code>生存期</code>。函数调用结束，释放存储单元，结束生存期。因此函数调用结束之后，自动变量的值不能保留。在复合语句中定义的自动变量，在退出复合语句后也不能再使用，否则将引起错误。</p>
<p>　　由于自动变量的作用域和生存期都<code>局限于定义它的个体内</code>(函数或复合语句内)，因此不同的个体中允许使用同名的变量而不会混淆。即使在函数内定义的自动变量也可与该函数内部的复合语句中定义的自动变量同名。</p>
<h2 id="二、外部变量的类型说明符为extern"><a href="#二、外部变量的类型说明符为extern" class="headerlink" title="二、外部变量的类型说明符为extern"></a>二、外部变量的类型说明符为extern</h2><p>　　1.外部变量和全局变量是对同一类变量的两种不同角度的提法。全局变量是从它的作用域提出的，外部变量从它的存储方式提出的，表示了它的生存期。<br>　　2.当一个源程序由若干个源文件组成时，在一个源文件中定义的外部变量在其它的源文件中也有效。</p>
<h2 id="三、静态变量static"><a href="#三、静态变量static" class="headerlink" title="三、静态变量static"></a>三、静态变量static</h2><h3 id="1、静态局部变量"><a href="#1、静态局部变量" class="headerlink" title="1、静态局部变量"></a>1、静态局部变量</h3><p>静态局部变量属于静态存储方式，它具有以下特点：</p>
<ol>
<li><p>静态局部变量在函数内定义，但不象自动变量那样，当调用时就存在，退出函数时就消失。静态局部变量始终存在着，也就是说它的生存期为整个源程序。</p>
</li>
<li><p>静态局部变量的生存期虽然为整个源程序，但是其作用域仍与自动变量相同，即只能在定义该变量的函数内使用该变量。退出该函数后，尽管该变量还继续存在，但不能使用它。</p>
</li>
<li><p>允许对构造类静态局部量赋初值。在数组一章中，介绍数组初始化时已作过说明。若未赋以初值，则由系统自动赋以0值。</p>
</li>
<li><p>对基本类型的静态局部变量若在说明时未赋以初值，则系统自动赋予0值。而对自动变量不赋初值，则其值是不定的。根据静态局部变量的特点，可以看出它是一种生存期为整个源程序的量。虽然离开定义它的函数后不能使用，但如再次调用定义它的函数时，它又可继续使用，而且保存了前次被调用后留下的值。因此，当多次调用一个函数且要求在调用之间保留某些变量的值时，可考虑采用静态局部变量。虽然用全局变量也可以达到上述目的，但全局变量有时会造成意外的副作用，因此仍以采用局部静态变量为宜。</p>
</li>
</ol>
<h3 id="2、静态全局变量"><a href="#2、静态全局变量" class="headerlink" title="2、静态全局变量"></a>2、静态全局变量</h3><p>　　全局变量(外部变量)的说明之前再冠以static就构成了静态的全局变量。全局变量本身就是静态存储方式，静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。从以上分析可以看出，把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static这个说明符在不同的地方所起的作用是不同的。应予以注意。</p>
<h2 id="四、寄存器变量register"><a href="#四、寄存器变量register" class="headerlink" title="四、寄存器变量register"></a>四、寄存器变量register</h2><p>　　上述各类变量都存放在存储器内，因此当对一个变量<code>频繁读写</code>时，必须要反复访问内存储器，从而<code>花费大量的存取时间</code>。为此，C语言提供了另一种变量，即寄存器变量。这种变量存放在CPU的寄存器中，使用时，不需要访问内存，而直接从寄存器中读写，这样可提高效率。寄存器变量的说明符是register。对于循环次数较多的循环控制变量及循环体内反复使用的变量均可定义为寄存器变量。</p>
<ol>
<li>只有局部自动变量和形式参数才可以定义为寄存器变量。因为寄存器变量属于<code>动态存储</code>方式。凡需要采用静态存储方式的量不能定义为寄存器变量。</li>
<li>在Turbo C，MS C等微机上使用的C语言中，实际上是把寄存器变量当成自动变量处理的。因此速度并不能提高。而在程序中允许使用寄存器变量只是为了与标准C保持一致。3.即使能真正使用寄存器变量的机器，由于CPU中寄存器的个数是有限的，因此使用寄存器变量的个数也是有限的。</li>
</ol>
</br>

<h1 id="8、递归函数"><a href="#8、递归函数" class="headerlink" title="8、递归函数"></a>8、递归函数</h1><p>C语言中的函数可以递归调用，即函数可以直接或间接调用自身。我们考虑下将一个数作为字符串打印的情况。前面讲过，数字是以反序生成的:低位数字先于高位数字生成，但它们必须以与此相反的次序打印。</p>
<p>解决该问题有两种方法。一种方法是将生成的各个数字依次存储到一个数组中，然后再以相反的次序打印它们，这种方式与3.6节中itoa函数的处理方式相似。另一种方法则是使用递归，函数printd首先调用它自身打印前面的(高位)数字，然后再打印后面的数字。这里编写的函数不能处理最大的负数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">/*printd:printnin decimal */</span><br><span class="line">void printd(int n)</span><br><span class="line">&#123;</span><br><span class="line">    if(n&lt;O)&#123;</span><br><span class="line">        putchar(&#x27;-&#x27;);</span><br><span class="line">        n =- n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if(n/10)</span><br><span class="line">        printd(n /10);</span><br><span class="line">    putchar(n % 10 + &#x27;0&#x27;):</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数递归调用自身时，每次调用都会得到一个与以前的自动变量集合不同的新的自动变量集合。因此，调用printd(123)时，第一次调用printd的参数n=123.它把12传递给printa的第二次调用，后者又把1传递结printd的第三次调用。第三次调用printd时首先将打印1.然后再返回到第二次调用。从第三次调用返回后的第二次调用同样也将先打印2，然后再返回到第一次调用。返回到第一次调用时将打3,随之结束函数的执行。</p>
<p>另外一个能较好说明递归的例子是快速排序.快速排序算法是C.A R. Hoare于1962年发明的。对于一个给定的数组，从中选择一个元素，以该元素为界将其余元素划分为两个子集，一个子集中的所有元紧都小于该元索，另一个子集中的所有元素都大于或等于该元素。对这样两个子集递归执行这一过程，当某个子集中的元素数小于2时，这个子集就不需要再次排序，终止递归。</p>
<p>从执行速度来讲，下列版本的快速排序函数可能不是最快的，但它是最简单的算法之.在每次划分子集时，该算法总是选取各个子数组的中间元素。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* qsort: sort v[1eft]...v[right] into increasing order */</span><br><span class="line"></span><br><span class="line">void qsort(int v[], intleft, int right)</span><br><span class="line">&#123;</span><br><span class="line">    int i, last;</span><br><span class="line">    void swap(int v[], int i, int j):</span><br><span class="line">    if (left &gt;= right) /* do nothing if array containg */</span><br><span class="line">        return; /*fewer than two elements */</span><br><span class="line">    swap(v, left, (left + right)/2);  /* move partition elem */</span><br><span class="line">    last = left;</span><br><span class="line">    for (i = left + 1;1 &lt;= right; i++)/* partition *</span><br><span class="line">        if (v[1] &lt; v[left])</span><br><span class="line">            swap(v, ++last,i);</span><br><span class="line">    swap(v, left, last);/* restore partition elem */</span><br><span class="line">    qsort(v, left, last-1);</span><br><span class="line">    qsort(v, last+1, right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里之所以将数组元素交换操作放在一个单独的函数swap中，是因为它在qsort函数中要使用3次。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/* swap: interchange v[i] andv[j]*/</span><br><span class="line"></span><br><span class="line">void swap (intv[]，inti，intj)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line"></span><br><span class="line">    temp =v[i];</span><br><span class="line">    V[i]=V[j]];</span><br><span class="line">    v[j]=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>标准库中提供了一个qsort函数，它可用于对任何类型的对象排序。</p>
<p>递归并不节省存储器的开销，因为递归调用过程中必须在某个地方维护一个存储处理值的栈。递归的执行速度并不快，但递归代码比较紧凑，并且比相应的非递归代码更易于编写与理解。在描述树等递归定义的数据结构时使用递归尤其方便。</p>
</br>



</div><div class="article-licensing box"><div class="licensing-title"><p>c语言程序设计</p><p><a href="https://wanyne-max.github.io/2021/08/09/c语言程序设计/">https://wanyne-max.github.io/2021/08/09/c语言程序设计/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>作者</h6><p>Wanyne W</p></div></div><div class="level-item is-narrow"><div><h6>发布于</h6><p>2021-08-09</p></div></div><div class="level-item is-narrow"><div><h6>更新于</h6><p>2021-08-10</p></div></div><div class="level-item is-narrow"><div><h6>许可协议</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><!--!--></article></div><!--!--><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2021/08/10/%E6%8C%87%E9%92%88/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">指针</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2021/08/08/UTC-UT-GMT%20%20%E6%97%B6%E5%8C%BA%E5%92%8C%E6%97%B6%E9%97%B4%E6%88%B3/"><span class="level-item">UTC-UT-GMT  时区和时间戳</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><!--!--></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar is-rounded" src="/img/avatar.png" alt="Wanyne W"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Wanyne W</p><p class="is-size-6 is-block">所有命运的馈赠 早已暗中标注了价格</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">文章</p><a href="/archives"><p class="title">16</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">分类</p><a href="/categories"><p class="title">6</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">标签</p><a href="/tags"><p class="title">0</p></a></div></div></nav></div></div><div class="card widget" data-type="categories"><div class="card-content"><div class="menu"><h3 class="menu-label">分类</h3><ul class="menu-list"><li><a class="level is-mobile" href="/categories/Blog/"><span class="level-start"><span class="level-item">Blog</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/Git/"><span class="level-start"><span class="level-item">Git</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile" href="/categories/Redis/"><span class="level-start"><span class="level-item">Redis</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"><span class="level-start"><span class="level-item">学习笔记</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile" href="/categories/%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">网络</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile" href="/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/"><span class="level-start"><span class="level-item">考研复习</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></div></div></div><div class="card widget" data-type="archives"><div class="card-content"><div class="menu"><h3 class="menu-label">归档</h3><ul class="menu-list"><li><a class="level is-mobile" href="/archives/2021/08/"><span class="level-start"><span class="level-item">八月 2021</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><!--!--><div class="card widget" data-type="recent-posts"><div class="card-content"><h3 class="menu-label">最新文章</h3><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-26T14:33:35.000Z">2021-08-26</time></p><p class="title"><a href="/2021/08/26/%E4%B8%BA%E4%BB%80%E4%B9%88redis%E8%BF%99%E4%B9%88%E5%BF%AB/">为什么redis这么快</a></p><p class="categories"><a href="/categories/Redis/">Redis</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-22T15:11:46.000Z">2021-08-22</time></p><p class="title"><a href="/2021/08/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/">正则表达式笔记</a></p><p class="categories"><a href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-13T00:37:33.000Z">2021-08-13</time></p><p class="title"><a href="/2021/08/13/%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E4%B9%8B%E5%90%8E%E5%8F%91%E7%94%9F%E7%9A%84%E7%A7%8D%E7%A7%8D/">输入网址之后的种种</a></p><p class="categories"><a href="/categories/%E7%BD%91%E7%BB%9C/">网络</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-10T00:59:49.000Z">2021-08-10</time></p><p class="title"><a href="/2021/08/10/%E6%9D%82%E7%83%A9/">杂烩</a></p><p class="categories"><a href="/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/">考研复习</a></p></div></article><article class="media"><div class="media-content"><p class="date"><time dateTime="2021-08-10T00:50:22.000Z">2021-08-10</time></p><p class="title"><a href="/2021/08/10/%E6%8C%87%E9%92%88/">指针</a></p><p class="categories"><a href="/categories/%E8%80%83%E7%A0%94%E5%A4%8D%E4%B9%A0/">考研复习</a></p></div></article></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Wanyne&#039;s Blog" height="28"></a><p class="is-size-7">   <span>&copy; 2021 Wanyne W</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p><p class="is-size-7">Made by Wanyne W</p><p class="is-size-7">Hope you have a good day！ ♥</p><p class="is-size-7">Creation date : 2021 08 05</p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" defer></script><script>moment.locale("zh-CN");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="回到顶端" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "此网站使用Cookie来改善您的体验。",
          dismiss: "知道了！",
          allow: "允许使用Cookie",
          deny: "拒绝",
          link: "了解更多",
          policy: "Cookie政策",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="想要查找什么..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"想要查找什么...","untitled":"(无标题)","posts":"文章","pages":"页面","categories":"分类","tags":"标签"});
        });</script></body></html>